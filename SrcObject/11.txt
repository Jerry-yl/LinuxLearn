/*************************************************************************
* 文件名称 : ZigBee.c
* 功    能 : 通过 带wifi模块的 ZigBee网络主控节点 控制 多个 ZigBee子节点.
*
* 当前版本 : 2.0
* 开 发 者 : Jerry
* 修改时间 : 2015.2.5
*
* 历史版本 : 1.0
* 开 发 者 : zhulin
* 完成时间 : 2014年11月20日
* 
* 备    注 : 1. 检验和 (除了 包头, 包尾, 其他所有数据的XOR)(经验的数据是原始数据,不是转义了的数据)
*            2. 控制灯亮度的消息: (校验码要重新计算) (倒数第三个字节为led灯的亮度)
*                   		01 00 81 00 08 5C 07 A3 0E 01 01 01 00 00 03
*            3. 匹配led的节点(只返回短地址)
*                  		01 00 46 00 08 4E FF FF 01 04 01 00 06 00 03
*            4. 获得MAC地址
*                 		01 00 41 00 06 72 A3 0E A3 0E 00 00 03
*            5. 测试LED的参数:
*                  		短地址: 0xA30E.   IEEE地址 : 00 15 8D 00-00 36 02 D4
*                  		短地址: 0xA30E.   IEEE地址 : 00 00 36 02 D4
*************************************************************************/
//#include "ZigBee.h"

//#include "iot_api.h"     //定义 IOT_BUFFER_LEN

//#include "../aswPrintf.h"

#include "asw_include.h" // ZigBee.h aswPrintf.h

//=====================================================
#define ZIGBEE_ASW_DEBUG

//调试打印输出
#ifdef ZIGBEE_ASW_DEBUG
	#define ZIGBEE_ASW_PRINTF           Printf_High
	#define ZIGBEE_ASW_OUTSTR(a, b)     aswPutStr((a), (b))
#else
	#define ZIGBEE_ASW_PRINTF           aswPrintf_NULL
	#define ZIGBEE_ASW_OUTSTR(a, b)
#endif

//--------------------------------------------------
#define NODE_NUM_MAX        			80   //节点的最大数目

//---------------------------------------------//规范的设备类型,0x0100:开关LED, 0x0101:可调亮度LED，0x0102:可调颜色LED
//#define 	LIGHT_ONOFF_CTRL			0x0100
//#define 	LIGHT_LEVEL_CTRL			0x0101
//#define 	LIGHT_COLOUR_CTRL			0x0102
//#define	CONTROLLER_DEV_TYPE			0x0104

//---------------------------------------------//不规范的设备类型(串口调试得知)
#define 	LIGHT_ONOFF_CTRL			0x0200
#define 	LIGHT_LEVEL_CTRL			0x0100
#define 	LIGHT_COLOUR_CTRL		0x01FF
#define	CONTROLLER_DEV_TYPE		0x0104

//---------------------------------------------//获取属性值要指定属性所在的Cluster ID
#define 	CLUSTER_ID_ONOFF_CTRL	0x0006 
#define 	CLUSTER_ID_LEVEL_CTRL	0x0008
#define 	CLUSTER_ID_COLOUR_CTRL	0x0300

//---------------------------------------------//上层发送的控制命令类型
#define	UP_CMD_ADD_NODE		0x0470//添加新节点的命令
#define	UP_CMD_GROUP_CTRL		0x0A00//以组地址方式控制命令
#define 	UP_CMD_SHORT_CTRL		0x0B00//以短地址方式控制命令

#define	UP_CMD_CREATE_SCENE		0x0501//创建一个新场景
#define	UP_CMD_DEL_SCENE		0x0502//删除一个场景
#define	UP_CMD_CHANGE_SCENE		0x0504//修改场景
#define	UP_CMD_RECALL_SCENE		0x0505//操作场景(恢复场景)

#define	UP_SUB_CMD_ONOFF		0x10//控制开关的命令
#define	UP_SUB_CMD_LEVEL		0x18//控制亮度的命令
#define	UP_SUB_CMD_COLOUR		0x20//控制色温的命令

#define    UP_SUB_CMD_BIND			0x10//绑定命令

//----------flushNodeState----------
#define	FlushNodeState    			0x50//刷新节点状态标记
#define	ClearFlushFlag				0x0A//不需要刷新节点状态标记

//----------operateGroupFlag--------
#define	HavaOperateGroup			0x50//上层有对组的操作
#define	ClearOperateFlag			0xA0//上层没有对组的操作

//----------ableCtrlFlag------------
#define	UnableCtrl	      			0x50//禁止上层发送控制命令标记
#define	AllowCtrl 	                        	0x0A//允许上层发送控制命令标记

//----------ctrlStateFlag-----------
#define	EnterCtrlState				0x50//进入控制状态标记
#define	ClearCtrlState				0x0A//不进入控制状态标记

//----------upMsgBufferState--------
#define	BufferEmpty				0x00//空缓存
#define	BufferExist				0x50//有缓存

//---------------------------------------------
typedef enum t_deviceZigBeeState
{
	ZIGBEE_INIT = 1,//初始化网络
	ZIGBEE_OBTAIN_SHORT_ADDR,//获得节点短地址
	ZIGBEE_QUERY_NODE_ATTR,//查询节点相关属性
	ZIGBEE_QUERY_NODE_STATE,//查询节点状态(包括当前状态值和在线状态)
	ZIGBEE_QUERY_GROUP_ADDR,//查询节点组地址
	ZIGBEE_INTERVAL_TIME,//待机
}DeviceZigBee_State;

typedef enum t_subStateBackFlag{
	SUB_STATE_RUN = 1,//子状态运行标记
	SUB_STATE_END,//子状态结束标记
}SubState_BackFlag;

//------------------------------------------------------------
typedef enum t_nodeIndicate{
	NODE_OBTAIN_ONLINE_FLAG 		= 0x01,//标记该节点在线,bit0
	
	NODE_OBTAIN_IEEE_ADDR_FLAG   	= 0x02,//标记该节点已查询Ieee地址,bit1
	NODE_OBTAIN_END_POINT_FLAG 	= 0x04,//标记该节点已查询通信端口号，bit2
	NODE_OBTAIN_DEV_TYPE_FLAG     	= 0x08,//标记该节点已查询设备类型，bit3
	NODE_OBTAIN_ATTR_COMPLETE	= 0x0E,//指示节点属性完整(0x02+0x04+0x08)

	NODE_OBTAIN_GROUP_ADDR_FLAG= 0x10,//标记该节点已查询组地址信息,bit4
	NODE_GROUP_STORE_FULL_FLAG	= 0x20,//标记该节点储存的组地址已满,bit5

	NODE_INIT_OBTAIN_GROUP_FLAG  = 0xC0,//标记该节点已初始化获取组地址,bit7,bit6(用两位标记更安全,其中一位有变化其结果还是不变的)
}NodeIndicate;//节点指示标记


//------------------------------------------------------------
typedef enum t_nodeMsgType{	
	Resp_IEEE_ADDR_TYPE   		= 0x0001,//获取IEEE地址的节点响应消息类型
	Resp_DEVICE_TYPE				= 0x0002,//获取设备类型的节点响应消息类型
	Resp_NODE_END_POINT_TYPE 	= 0x0004,//获取通信端口号的节点响应消息类型
	Resp_STATE_VALUE_TYPE  		= 0x0008,//获取状态值的节点响应消息类型

	Resp_NEW_NODE_TYPE  			= 0x0010,//新节点加入的节点响应消息类型
	Resp_NODE_DEFAULT_TYPE 		= 0x0020,//控制OK的节点默认响应消息类型

	Resp_ADD_GROUP_TYPE 			= 0x0040,//添加节点的指定端口到组中的节点响应消息类型
	Resp_GET_GROUP_ADDR_TYPE 	= 0x0080,//获取节点指定端口所在的组地址的节点响应消息类型
	Resp_REMOVE_GROUP_TYPE 		= 0x0100,//删除节点指定端口所在的指定组的节点响应消息类型

	Resp_BIND_TYPE				= 0x0200,//绑定节点的响应消息类型
}ReceNodeMsgType;//接收的节点消息响应的类型

//------------------------------------------------------------
typedef union t_node_State{
	struct{
		UINT8 	onOffValue;//存储开关状态值(0:关，1:开)
	}onOffNode;
	struct{
		UINT8 	levelValue;//存储亮度等级状态值(有效值: 0x01 - 0xFE) (0x00:关,0xFF=0xFE)
	}levelNode;
	struct{
		UINT8 	levelValue;//存储可控色温灯的亮度等级状态值(有效值: 0x01 - 0xFE)
		UINT8 	colourTempValue;//存储可控色温灯的色温状态值(有效值:0x00 - 0xD8)
	}colourTempNode;
}NodeStateUnion;//节点状态值，包括onoff,level ,colour temperature

//------------------------------------------------------------
typedef struct {
	UINT8	validFlag;//标记遥控器节点的信息是否有效，0x55:有效，0x00:无效
	UINT8	IeeeAddr[8];//遥控器的IEEE地址;
	UINT16	controllerType;//遥控器的类型;
}controller_Info_Class;//遥控器节点信息结构体

/*****************************************************************************
*                        节点信息结构体                                      *
*****************************************************************************/
typedef struct {
	UINT8      IeeeAddr[8];  		//Ieee地址
	UINT8	endPoint;		        //通信端口号	
	UINT16	shortAddr; 		//短地址
	UINT16    deviceType;   		//设备类型,0x0100:开关LED, 0x0101:可调亮度LED，0x0102:可调颜色LED

	UINT16	nodeGroupAddr;//节点所在组地址相与之和,每一位表示不同的组(节点实际存在的组)
	UINT16	upGroupAddr;//上层操作的节点组地址的缓存组地址(上层发送的组)
	
	UINT8       nodeIndicate;//在查询过程中的节点指示标记
	NodeStateUnion  currentState;//存储节点的当前状态
}Node_Info_Class; //APP应答的结构体

typedef struct {
	DeviceZigBee_State    state; //状态机
	UINT8      sequence; //查询状态机的状态序号.
	UINT8	ctrlSequence;//控制状态机的状态序号.
	
	UINT32	sendCmdTime;//发送命令的时间(单位:ms)
	UINT32    receUartTime;//接收命令的时间(单位:ms)

	UINT8	flushNodeFlag;//刷新节点状态标记.值解释:0x50:需要刷新.0x0A:不需要刷新;
	UINT8      operateGroupFlag;//上层有关对组的操作的标记.值解释:0x50:有操作.0x0A:没有操作;
	
	UINT8 	ableCtrlFlag;//发送控制命令.值解释:0x50:不能发送控制命令,0x0A:能发送控制命令
	UINT8	ctrlStateFlag;//控制状态标记.值解释:0x50:进入控制状态,0x0A:接收到上层命令
	
	UINT8     	cmdAckFlag;//发送的每个命令,都会收到0x8000的应答,这个是应答的标志,0:OK.

	UINT8 	nodeRespStatus;//保存子节点反馈的消息中的状态值(0x00:success,other:fail)
	
	UINT16 	nodeShortAddr;//临时保存当前查询节点的节点短地址

	UINT16  	nodeMsgRespType;//接收ZigBee节点消息响应的类型
	
	Node_Info_Class    	 gNodeInfo[NODE_NUM_MAX];//保存节点的信息
}deviceZigBee_Object_t; //ZigBee 的状态机

//-------------------------------------------------------
typedef struct t_up_Msg_Buffer{ 
	UINT8	upMsgBufferState;//缓存状态标记(0x00:缓存为空，0x50:缓存结束)

	UINT8	upDataBlock[ASW_PROTOCOL_BLOCK_MAX_LEN];//协议数据中的数据块
	WIFI_PROCOTOL_PARM   wifiProcotolParm;//wifi协议数据
}upMsgBuffer;//缓存上层发送过来的一条消息

//-------------------------------------------------------
typedef struct t_Resp_Up_Msg_Buffer{
	UINT8	upDataBlock[ASW_PROTOCOL_BLOCK_MAX_LEN];//协议数据中的数据块
	WIFI_PROCOTOL_PARM   wifiProcotolParm;//wifi协议数据(当清除缓存前，把缓存中的该变量值赋值给该变量)(避免清除缓存时把该变量值清空，因为响应上层的需要)
}respUpBuffer;//上层发送控制命令后响应上层需要的临时缓存

//--------------- 常量 ---------------------------------------------
const UINT8   cmd11[] = {0x01,0x00,0x11,0x00,0x00,0x11,0x03};//RESET
const UINT8   cmd12[] = {0x01,0x00,0x10,0x00,0x00,0x10,0x03};//GET VERSION
const UINT8   cmd13[] = {0x01,0x00,0x23,0x00,0x01,0x22,0x00,0x03};//SET DEVICETYPE
const UINT8   cmd14[] = {0x01,0x00,0x21,0x00,0x04,0x31,0x00,0x00,0x00,0x14,0x03};//SET CHANNELMASK
const UINT8   cmd15[] = {0x01,0x00,0x20,0x00,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03};//SET EXT PANID
const UINT8   cmd16[] = {0x01,0x00,0x24,0x00,0x00,0x24,0x03};//START NETWORK

const UINT8   cmd21[] = {0x01,0x00,0x46,0x00,0x08,0x4E,0xFF,0xFF,0x01,0x04,0x01,0x00,0x06,0x00,0x03};//获取已在网络的LED节点短地址(0x0060 Cluster)

const UINT8   cmd31[] = {0x01,0x00,0x41,0x00,0x06,0x72,0xA3,0x0E,0xA3,0x0E,0x00,0x00,0x03};//通过短地址,获得Ieee地址
const UINT8   cmd32[] = {0x01,0x00,0x45,0x00,0x02,0x9F,0x78,0xA0,0x03};//获取节点的通信端口
const UINT8   cmd33[] = {0x01,0x00,0x43,0x00,0x03,0x99,0x78,0xA0,0x01,0x03 };//获取节点的设备类型

const UINT8   cmd41[] = {0x01,0x01,0x00,0x00,0x0E,0xFA,0x02,0x78,0xA0,0x01,0x01,0x00,0x06,0x00,0x00,0x12,0x34,0x01,0x00,0x00,0x03};//读取节点的状态值

const UINT8   cmd61[] = {0x01,0x00,0x60,0x00,0x07,0x91,0x02,0x38,0xCC,0x01,0x01,0x00,0x00,0x03};//Add Group(添加节点的指定端口到组中)
const UINT8   cmd62[] = {0x01,0x00,0x62,0x00,0x06,0x17,0x02,0x96,0xE7,0x01,0x01,0x00,0x03};//Get Group Membership(获取节点指定端口所在的组地址)
const UINT8   cmd63[] = {0x01,0x00,0x63,0x00,0x07,0xB4,0x02,0x38,0xCC,0x01,0x01,0x00,0x00,0x03};//Remove Group(删除节点指定端口的指定组)

                        //01  00  49  00  04  72  FF  FC  [3C]  00  03 
const UINT8   cmd71[] = {0x01,0x00,0x49,0x00,0x04,0x72,0xFF,0xFC,0x3C,0x00,0x03};//PERMIT JOINING REQUEST(允许加入新节点时间定为60s)

			//01  00  92  00  06  4E  02  [78  A0]  01 [01] [00]  03
const UINT8   cmd72[] = {0x01,0x00,0x92,0x00,0x06,0x4E,0x02,0x78,0xA0,0x01,0x01,0x00,0x03};//控制开关的命令(00:关，01:开，02:切换开和关)						 

                        //01  00  81  00  09  AC  02  [A3  0E]  01 [01]  01  [FF] 00  00  03
const UINT8   cmd73[] = {0x01,0x00,0x81,0x00,0x09,0x5C,0x02,0xA3,0x0E,0x01,0x01,0x01,0xFF,0x00,0x00,0x03};//控制亮度的命令

                        //01  00  C0  00  09  07  02  [B0  66]  01 [01] [00  01] 00  00  03
const UINT8   cmd74[] = {0x01,0x00,0xC0,0x00,0x09,0x07,0x02,0xB0,0x66,0x01,0x01,0x00,0x01,0x00,0x00,0x03};//控制色温的命令

			//01  00  A4  00  08  91  01  [DD  65]  01  01  [00  01] [01] 03
const UINT8   cmd75[] = {0x01,0x00,0xA4,0x00,0x08,0x91,0x01,0xDD,0x65,0x01,0x01,0x00,0x01,0x01,0x03};//创建一个新场景
			//01  00  A2  00  08  20  01  [1E  95]  01  01  [00  01] [02] 03
const UINT8   cmd76[] = {0x01,0x00,0xA2,0x00,0x08,0x20,0x01,0x1E,0x95,0x01,0x01,0x00,0x01,0x02,0x03};//删除一个场景
			//01  00  A5  00  08  91  01  [DD  65]  01  01  [00  01] [01] 03
const UINT8   cmd77[] = {0x01,0x00,0xA5,0x00,0x08,0x91,0x01,0xDD,0x65,0x01,0x01,0x00,0x01,0x01,0x03};//操作场景(恢复场景)
			//01  00  30  00  15  C1  [00  15 8D 00 00 36 1D D6] 01 00 06 [03] [00 15 8D 00 00 7B F3 94] [01] 03 
const UINT8   cmd78_IeeeAddr[] = {0x01,0x00,0x30,0x00,0x15,0xC1,0x00,0x15,0x8D,0x00,0x00,0x36,0x1D,0xD6,0x01,0x00,0x06,0x03,0x00,0x15,0x8D,0x00,0x00,0x7B,0xF3,0x94,0x01,0x03};
			//01  00  30  00  0F  DE  [00 15 8D 00 00 36 1D D6]  01 00 06 [01] [6C EC]s 01 03 
const UINT8   cmd78_GroupAddr[] = {0x01,0x00,0x30,0x00,0x0F,0xDE,0x00,0x15,0x8D,0x00,0x00,0x36,0x1D,0xD6,0x01,0x00,0x06,0x01,0x6C,0xEC,0x01,0x03};
//--------------- 局部函数 ------------------------------------------
void 		QueryStateMachine(void);//正常的初始化，查询状态机
SubState_BackFlag  ModelInitState(void) XIP_ATTRIBUTE(".xipsec0");//ZigBee模块初始化.
SubState_BackFlag 	ObtainShortAddrState(void) XIP_ATTRIBUTE(".xipsec0");//获取节点短地址.
SubState_BackFlag  QueryNodeAttrState(void) XIP_ATTRIBUTE(".xipsec0");//查询节点相关属性.
SubState_BackFlag  QueryGroupAddrState(void) XIP_ATTRIBUTE(".xipsec0");//查询节点组地址.
SubState_BackFlag  QueryNodeState(void) XIP_ATTRIBUTE(".xipsec0");//查询节点状态值.
SubState_BackFlag 	ControlNodeState(void) XIP_ATTRIBUTE(".xipsec0");//控制节点.

UINT8   AddShortAddr(UINT8 *pShortAddr,UINT8 *pEndPoint);//添加节点的短地址和通信端口.
UINT8   AddNewNodeAddr(UINT8 *pShortAddr,UINT8 *pIeeeAddr);//添加新节点的短地址和Ieee地址.
UINT8   AddIeeeAddr(UINT16 iShortAddr, UINT8 *pIeeeAddr);//添加节点的Ieee地址.
UINT8   AddNodeEndPoint(UINT16 iShortAddr, UINT8 *pEndPoint);//添加节点的通信端口号.
UINT8   AddDeviceType(UINT16 iShortAddr,UINT8 *pDeviceType);//添加节点的设备类型.
UINT8   AddCurrentStateValue(UINT16 iShortAddr,UINT8 *pClusterID,UINT8 *pStateValue);//添加节点的状态值
UINT8   AddGroupAddr(UINT16 iShortAddr, UINT8 iGroupCapacity, UINT8 iGroupCount, UINT8 *pGroupAddr);//添加节点所在组的组地址

UINT8   GetAttrQueryNumber(UINT8 iQueryNumber);//获得节点属性不完整的查询编号.
UINT8   GetGroupQueryNumber(UINT8 iQueryNumber);//获得节点组地址的查询编号.
UINT8   GetStateQueryNumber(UINT8 iQueryNumber);//获得节点状态的查询编号.
UINT8   GetNodeNum(void);//获得节点数目.

UINT8   AddNodeToGroup(UINT8 *pIeeeAddr, UINT8 iAddNum, UINT8 iGroupNum);//添加节点到组里.
UINT8   DelNodeFromGroup(UINT8 *pIeeeAddr, UINT8 iAddNum, UINT8 iGroupNum);//删除组里的节点.

UINT8   SearchNode(UINT8 *pIeeeAddr);//通过上层发送的节点Ieee地址匹配短地址和提取节点编号.

UINT16 QuerySlaveAllMac(UINT8 *pAckData, UINT8 StartMAC, UINT8 iNum);//查询ZigBee的所有节点的MAC地址信息。
UINT16 QuerySlaveOneMac(UINT8 *pIeeeAddr, UINT8 *pAckData);//查询ZigBee的指定节点的信息.

UINT16  u16QueryControllerInfo(UINT8 *pAckData);//查询ZigBee的遥控器节点的信息.

UINT16 ProtocolDevTypeParse(UINT8 *pDataAddr, UINT8 *pProtocolData, UINT8 *ackBuf, UINT8 *err);//解析协议的二级子设备的设备类型
UINT16 ProtocolCmdTypeParse(UINT8 *pDataAddr, UINT8 *pProtocolData, UINT8 *ackBuf, UINT8 *err);//解析协议的二级子设备的命令字
	
void	     SendUartCommand(const UINT8 * iBuf, const UINT16 iLen);//wifi模块 通过串口 发送数据到 ZigBee 模块.
void	     StateJump(DeviceZigBee_State iState);//一级状态跳转.
void       ClearNodeAllFlag(void);//清除节点的所有标记位,让节点重新获取所有数据.
void	     ClearNodeQueryGroupFlag(UINT8 iDelGroupNum);//清除删除组内的 节点已查询组的标记位.

UINT16 CodingEscapeString(UINT8 *pDestBuff, const UINT8 *pSrcBuff, const UINT16 iLen, UINT8 iCheckSum);//将原始协议包转义.
UINT16 DecodeEscapeString(UINT8 *pBuff, const UINT16 iLen);//解码 转义的消息.

void	     RefreshFlashGroupFlag(void);//刷新 组名.
UINT16 ReadGroupName(UINT8 *pBuff, UINT8 *ioNum, const UINT16 maxLen);//读取 组名.
UINT8   WriteGroupName(const UINT8 GroupNum, const UINT8 *pName, const UINT8 flag);//写一个 组名.
UINT8   DelGroupName(const UINT8 GroupNum);//删除 一个 组.

UINT8   CheckGroupAddr(UINT16 iGroupAddr);//检查组地址的有效性.
UINT8   CheckUpGroupNum(UINT8 iUpGroupNum);//检查上层要操作的组是否属于在线节点的组中.
UINT8   CheckGroupExist(UINT8 iUpGroupNum);//检查组是否还存在.

void      RefreshFlashSceneMatchGroup(void);
UINT16 ReadSceneName(UINT8 *pBuff, UINT8 *ioNum, const UINT16 maxLen);//读取 场景名
UINT8   WriteSceneName(const UINT8 GroupNum, const UINT8 SceneNum, const UINT8 *pName, const UINT8 flag);//写一个 场景名.
UINT8   DelSceneName(const UINT8 SceneNum);//删除 一个 场景.
UINT8   GetSceneNameLen(const UINT8 SceneNum);//通过场景编号,获取对应的场景名的长度.

UINT8   CheckSum(UINT8 *pBuff, const UINT16 iLen);//消息校验.

//--------------- 外部变量 ------------------------------------------
extern IOT_ADAPTER   IoTpAd;//用于读取flash的buff

//--------------- 内部全局变量 ------------------------------------------
static  deviceZigBee_Object_t   gZigBeeObject;//ZigBee 的状态机

static  controller_Info_Class	 gControllerInfo;//遥控器节点的信息

static  upMsgBuffer		         gUpMsgBuffer; //缓存上层发送过来的消息
static  respUpBuffer			 gRespUpBuffer;//响应给上层消息的临时缓存

static  UINT8				 gNodeQueryNumber;//节点查询的查询编号.

static  UINT16				 flashGroupData;//FLASH中存储的创建的组地址数据
static  UINT8  				 flashSceneMatchGroup[16];//flash中储存的场景对应的组编号
static  UINT16				 gNodeInvalidGroup[2];//节点地址和节点的无效组地址,[0]--节点短地址,[1]--节点无效组地址
//====================================================
#if  (ZIGBEE_ENABLED == 1)

/**************************************************************
* 名称 : deviceZigBee_HardwareGpioInit
* 功能 : 模块硬件GPIO 初始化.
*
* 参数 : 无
* 返回 : 无
*
* 备注 : 1.在硬件上电后,立即定义IO口的输入输出属性.
**************************************************************/
void deviceZigBee_HardwareGpioInit(void)
{
//	uint8_t    gpio_read, Polarity; //GPIO操作的参数
	uint32_t     gpio_input;

	//------------------------------------------
	IoT_gpio_output(WIFI_LED_GPIO, LED_OFF);//led指示灯为GPIO3

	//------------------------------------------
	IoT_gpio_input(RESET_KEY_GPIO, &gpio_input);//复位按键
}

/**************************************************************
* 名称 : deviceZigBee_init
* 功能 : ZigBee模块初始化.
*
* 参数 : iRestFlag : in : 复位标志. POWER_ON : 上电复位; SOFT_RST : 软件复位;
* 返回 : 无
*
* 备注 : 1.
**************************************************************/
void deviceZigBee_init(uint8_t iRestFlag)
{
	UINT8   i;

	iRestFlag = iRestFlag;

	StateJump(ZIGBEE_INIT);
	gZigBeeObject.ctrlSequence = 0;//控制状态机的状态序号.

	gZigBeeObject.sendCmdTime = GetMsTimer();//发送命令的时间(单位:ms)
	gZigBeeObject.receUartTime = gZigBeeObject.sendCmdTime;//接收命令的时间(单位:ms)

	gZigBeeObject.flushNodeFlag = ClearFlushFlag;//初始化为不需要刷新节点状态.值解释:0x50:需要刷新.0x0A:不需要刷新;
	gZigBeeObject.operateGroupFlag = ClearOperateFlag;//上层有关对组的操作的标记.值解释:0x50:有操作.0x0A:没有操作;
	
	gZigBeeObject.ableCtrlFlag = AllowCtrl;//初始化为允许发送控制命令.值解释:0x50:不能发送控制命令,0x0A:能发送控制命令
	gZigBeeObject.ctrlStateFlag = ClearCtrlState;//初始化为不进入控制状态.

	gZigBeeObject.cmdAckFlag = 0xFF;//发送的每个命令,都会收到0x8000的应答,这个是应答的标志,0:OK.

	gZigBeeObject.nodeRespStatus = 0xFF;//发送的命令,子节点若有响应的消息,其中便会附带status 字段,表明操作结果
	
	gZigBeeObject.nodeShortAddr = 0x0000;//初始化为0

	flashGroupData = 0x0000;//初始化为0
	
	for(i = 0; i < NODE_NUM_MAX; i++)
	{
		memset(&gZigBeeObject.gNodeInfo[i], 0, sizeof(Node_Info_Class));
	}

	//--初始化---------------------------------------
	memset(&gUpMsgBuffer, 0, sizeof(upMsgBuffer));
	memset(&gRespUpBuffer, 0, sizeof(respUpBuffer));
	memset(&gControllerInfo, 0,sizeof(controller_Info_Class));
	memset(gNodeInvalidGroup, 0, sizeof(gNodeInvalidGroup));
	memset(flashSceneMatchGroup, 0xFF,sizeof(flashSceneMatchGroup));
	
	RefreshFlashGroupFlag();//刷新 组名
	RefreshFlashSceneMatchGroup();//刷新场景对应的 组编号

	/* 检测场景相关联的组是否存在,不存在就要把该场景删除 */
	for(i=0;i<16;i++)
	{
		CheckGroupExist(flashSceneMatchGroup[i]);
	}
}

/**************************************************************
* 名称 : deviceZigBee_task
* 功能 : ZigBee模块任务.
*
* 参数 : 无
* 返回 : 无
*
* 备注 : 1.
**************************************************************/
void deviceZigBee_task(void)
{
	do{
		//-----------控制状态-------------------
		if(EnterCtrlState == gZigBeeObject.ctrlStateFlag)//是否进入控制状态
		{
			if(SUB_STATE_END == ControlNodeState())
			{
				gZigBeeObject.ctrlStateFlag = ClearCtrlState;//控制完成后清除控制状态标记
			}
			break;
		}
		else if((BufferExist == gUpMsgBuffer.upMsgBufferState) && (AllowCtrl == gZigBeeObject.ableCtrlFlag))//允许发送控制命令.值解释:0x50:不能发送控制命令,0x0A:能发送控制命令
		{//0x50有上层需要发送的命令缓存 && 允许上层发送控制命令标记
			gZigBeeObject.ctrlStateFlag = EnterCtrlState;//标记进入控制状态
			gZigBeeObject.ctrlSequence = 0;
			break;
		}

		//----------查询状态-------------------
		QueryStateMachine();//正常的初始化，查询状态机
	}while(0);
}

/**************************************************************
* 名称 : deviceZigBee_getInfo
* 功能 : 获得设备信息.
*
* 参数 : 无
* 返回 : info : out : 设备信息;
*
* 备注 : 1.ZigBee的设备信息:  节点设备MAC地址的个数.
**************************************************************/
uint32_t deviceZigBee_getInfo(void)
{
	uint32_t  info;
	info = (0 + 1)<<16;//版本号 0.01
	info += (0x20)<<8 ;//主控设备类型:	0x10: nRF24L01,  0x20: ZigBee
	info += GetNodeNum();

	ZIGBEE_ASW_PRINTF("************GetNodeNum:nodeNum:%d.\n", (info & 0x0F));
	return(info);//全部节点数
}


/**************************************************************
* 名称 : deviceZigBee_protocolParse
* 功能 : 解析 ZigBee设备的APP协议.
*
* 参数 : pWifiProtocolParm : in : 接收数据包中的一些协议参数;
*        iDataAddr         : in : 协议中数据块的首地址;
* 返回 : 无
*
* 备注 : 1.
**************************************************************/
void deviceZigBee_protocolParse(const WIFI_PROCOTOL_PARM * pWifiProtocolParm, const uint8_t *iDataAddr)
{
	uint8_t   ackBuf[ASW_PROTOCOL_MAX_LEN]={0};
	bool        needResp = FALSE;
	uint8_t   i, err, subErr, tempU8;
	uint16_t ackLen, subAckLen, tempU16;
	uint16_t tempDeviceType;

	if((pWifiProtocolParm == NULL) || (iDataAddr == NULL)) 
	{
		ZIGBEE_ASW_PRINTF("deviceZigBee_protocolParse: parameter err.\n");
		return;  
	}

	ZIGBEE_ASW_PRINTF("\n---------------------------\n");
	ZIGBEE_ASW_PRINTF("pro:Cmd:%x.", pWifiProtocolParm->cmd);
	
	needResp = FALSE;
	err = 0xFF;//默认出错
	switch (pWifiProtocolParm->cmd)//APP与wifi模块握手协议解析
	{
	//--查询节点设备参数---------------------------------------------------------------
	case 0x0400://查询从机节点的设备参数
		if(pWifiProtocolParm->dataLen != 4)  {  break;  }//数据块 长度错误
		err = 0;//默认结果OK
		do{
			tempDeviceType = wifiProtocol_getDataU16(iDataAddr);//设备类型
			if(tempDeviceType != DEVICE_TYPE)//设备类型不对
			{
				err = 0x11;  break;//0x11:设备类型错误
			}

			tempU16 = QuerySlaveAllMac(ackBuf, iDataAddr[2], iDataAddr[3]);
			gZigBeeObject.flushNodeFlag = FlushNodeState;//刷新节点状态标记
			
			if(tempU16 == 0) 
			{ 
				err = 0x10;  break;//参数错误
			}else{
				ackLen = tempU16;//应答的数据块长度
			}
		}while(0);

		if(err == 0)
		{
			needResp = TRUE; //发送应答
		} else {
			needResp = FALSE; //当前不应答
		}
	break;
	case 0x0410://查询遥控器的设备参数
		if(pWifiProtocolParm->dataLen != 10)  {  break;  }//数据块 长度错误
		err = 0;//默认结果OK
		do{
			tempDeviceType = wifiProtocol_getDataU16(iDataAddr);//设备类型
			if(tempDeviceType != DEVICE_TYPE)//设备类型不对
			{
				err = 0x11;  break;//0x11:设备类型错误
			}

			tempU16 = u16QueryControllerInfo(ackBuf);
			gControllerInfo.validFlag = 0x00;//清除遥控器信息，一旦被上层请求获取，就清除有效标记
			
			if(tempU16 == 0) 
			{ 
				err = 0x10;  break;//参数错误
			}else{
				ackLen = tempU16;//应答的数据块长度
			}
		}while(0);

		if(err == 0)
		{
			needResp = TRUE; //发送应答
		} else {
			needResp = FALSE; //当前不应答
		}
	break;
	//-----------------------------------
	case 0x0420://查询指定从机节点的设备参数
		if(pWifiProtocolParm->dataLen != 10)  {  break;  }//数据块 长度错误
		err = 0;//默认结果OK
		do{
			tempDeviceType = wifiProtocol_getDataU16(iDataAddr);//设备类型
			if(tempDeviceType != DEVICE_TYPE)//设备类型不对
			{
				err = 0x11;  break;//0x11:设备类型错误
			}

			tempU16 = QuerySlaveOneMac(&iDataAddr[2], ackBuf);
			gZigBeeObject.flushNodeFlag = FlushNodeState;//刷新节点状态标记
			
			if(tempU16 == 0) 
			{ 
				err = 0x10;  break;//参数错误
			}else{
				ackLen = tempU16;//应答的数据块长度
			}
		}while(0);

		if(err == 0)
		{
			needResp = TRUE; //发送应答
		} else {
			needResp = FALSE; //当前不应答
		}
	break;
	
	//--------------------------------------------------------------------
	case 0x0470://允许新节点加入网络
		if(pWifiProtocolParm->dataLen != 0x02)  {  break;  }//数据块长度错误
		err = 0x00;//默认结果OK
		do{
			tempDeviceType = wifiProtocol_getDataU16(iDataAddr);//设备类型
			if(tempDeviceType != DEVICE_TYPE)//设备类型不对
			{
				err = 0x11;  break;//0x11:设备类型错误
			}
			
			//---------------------------缓存上层数据-------------------------------
			if(BufferEmpty == gUpMsgBuffer.upMsgBufferState)//缓存为空
			{
				ZIGBEE_ASW_PRINTF(":buf OK.\n ");

				memcpy(gUpMsgBuffer.upDataBlock, iDataAddr, pWifiProtocolParm->dataLen);//缓存数据块
				gUpMsgBuffer.wifiProcotolParm = *pWifiProtocolParm;//wifi协议数据
				gUpMsgBuffer.upMsgBufferState = BufferExist;//有缓存
			}
		}while(0);

		if(err != 0)
		{
			ackBuf[0] = err;
			ackLen  = 1;  //应答的数据块长度
			needResp = TRUE;//发送应答
		} else {
			needResp = FALSE;//当前不应答
		}
	break;

	//--控制------------------------------------------------------------------
	case 0x0A00://组控节点
		//if(pWifiProtocolParm->dataLen != 10)  {  break;  }//数据块 长度错误
		subAckLen = 0xFFFF;//默认无效
		err = 0x00;//默认结果OK
		do{
			tempDeviceType = wifiProtocol_getDataU16(iDataAddr);//设备类型
			if(tempDeviceType != DEVICE_TYPE)  //设备类型不对
			{
				err = 0x11;  break;  //0x11:设备类型错误
			}

			if(BufferEmpty == gUpMsgBuffer.upMsgBufferState)//缓存为空
			{
				if((flashGroupData & (((UINT16)0x01) << iDataAddr[2])) == 0 )//组不存在
				{
					err = 0x13;  break; //0x13:组编号错误
				}
				ZIGBEE_ASW_PRINTF("-GroupNum:%x.",  iDataAddr[2]);
				
				subAckLen = ProtocolDevTypeParse(iDataAddr, &iDataAddr[2+1], &ackBuf[6], &subErr);//解析协议的二级子设备的设备类型和命令字,并且保存操作结果,上层要查询的查询值.
				if( 0x00 != subErr )
				{
					err = 0x10;  break; //0x10:参数错误
				}

				if( subAckLen < 0x1000 ) //是查询指令则不需要执行缓存步骤,直接取出数据反馈给上层
				{
					break;
				}else{
					//暂无
				}
				
				memcpy(gUpMsgBuffer.upDataBlock, iDataAddr, pWifiProtocolParm->dataLen);//缓存数据块
				gUpMsgBuffer.wifiProcotolParm = *pWifiProtocolParm;//wifi协议数据
				gUpMsgBuffer.upMsgBufferState = BufferExist;//有缓存
			} else {
				ZIGBEE_ASW_PRINTF("\n pro: Buf fail.\n");
			}
		}while(0);

		if( err != 0 ){
			memcpy(ackBuf, iDataAddr, 6);//主控设备类型,MAC地址,设备类型,命令字
			ackBuf[6] = err;
			ackBuf[7] = err;
			ackLen = 8;

			needResp = TRUE;     //发送应答
		}else if( subAckLen < 0x1000 ){
			memcpy(ackBuf, iDataAddr, 6);//主控设备类型,MAC地址,设备类型,命令字
			ackLen = 6 + subAckLen;//应答的数据块长度

			needResp = TRUE;     //发送应答
		} else {
			needResp = FALSE; //当前不应答
		}
	break;
	//---------------------------------
	case 0x0B00://控制节点
		//if(pWifiProtocolParm->dataLen != 11)  {  break;  }//数据块 长度错误
		subAckLen = 0xFFFF;//默认无效
		err = 0x00;//默认结果OK
		do{
			tempDeviceType = wifiProtocol_getDataU16(iDataAddr);//设备类型
			if(tempDeviceType != DEVICE_TYPE)  //设备类型 不对
			{
				err = 0x11;  break;  //0x11:设备类型错误
			}
			
			if(BufferEmpty == gUpMsgBuffer.upMsgBufferState)//缓存为空
			{
				subAckLen = ProtocolDevTypeParse(iDataAddr, &iDataAddr[2+8], &ackBuf[13], &subErr);//解析协议的二级子设备的设备类型和命令字,并且保存操作结果,上层要查询的查询值.
				if( 0x00 != subErr )
				{
					err = 0x10;  break; //0x10:参数错误
				}

				if( subAckLen < 0x1000 ) //是查询指令则不需要执行缓存步骤,直接取出数据反馈给上层
				{
					break;
				}else{
					//暂无
				}
			
				memcpy(gUpMsgBuffer.upDataBlock, iDataAddr, pWifiProtocolParm->dataLen);//缓存数据块
				gUpMsgBuffer.wifiProcotolParm = *pWifiProtocolParm;//wifi协议数据
				gUpMsgBuffer.upMsgBufferState = BufferExist;//有缓存
			}else{
				ZIGBEE_ASW_PRINTF("\n pro: buf Fail.\n");
			}
		}while(0);
		if( err != 0 ){//错误时的反馈
			memcpy(ackBuf, iDataAddr, 13);//主控设备类型,MAC地址,设备类型,命令字
			ackBuf[13] = err;
			ackBuf[14] = err;
			ackLen = 15;

			needResp = TRUE;     //发送应答
		}else if( subAckLen < 0x1000 ){//查询指令的反馈
			ZIGBEE_ASW_PRINTF(" pro:to  subAckLen < 0x1000.\n");
			memcpy(ackBuf, iDataAddr, 13);//主控设备类型,MAC地址,设备类型,命令字
			ackLen = 13 + subAckLen;//应答的数据块长度

			needResp = TRUE;     //发送应答
		}else{
			needResp = FALSE; //当前不应答
		}
	break;

	//--组的管理--------------------------------------------------------------
	case 0x0480://查询组信息
		if(pWifiProtocolParm->dataLen != 4)  {  break;  }//数据块 长度错误
		err = 0;//默认结果OK
		do{
			tempDeviceType = wifiProtocol_getDataU16(iDataAddr);//设备类型
			if(tempDeviceType != DEVICE_TYPE)//设备类型不对
			{
				err = 0x11;  break;//0x11:设备类型错误
			}

			ZIGBEE_ASW_PRINTF("Group:Start:%d.Num:%d.\n", iDataAddr[2], iDataAddr[3]);

			tempU8 = iDataAddr[2];//传入查询组名的开始编号,传出查询的组个数;
			tempU16 = ReadGroupName(&ackBuf[3], &tempU8, (ASW_PROTOCOL_BLOCK_MAX_LEN -3));//读取 组名
			
			if(tempU16 == 0) 
			{ 
				err = 0x10;  break;//参数错误
			} else {
				ackBuf[0] = 16;//主控设备保存组的个数.固定为16
				ackBuf[1] = iDataAddr[2];//查询组名的开始编号;
				ackBuf[2] = tempU8;//查询的组个数;
				ackLen = 3 + tempU16;//应答的数据块长度

				ZIGBEE_ASW_PRINTF("pro: groupNameLen:");
				ZIGBEE_ASW_OUTSTR(&ackBuf[3], 16);
				ZIGBEE_ASW_PRINTF(".\n");
			}
		}while(0);
		if(err == 0)
		{
			needResp = TRUE; //发送应答
		} else {
			needResp = FALSE; //当前不应答
		}
	break;
	//---------------------------------
	case 0x0481://创建一个组
		tempU16 = pWifiProtocolParm->dataLen;//数据块 长度
		if(pWifiProtocolParm->dataLen > 65)  {  break;  }//数据块 长度错误
		err = 0;//默认结果OK
		do{
			tempDeviceType = wifiProtocol_getDataU16(iDataAddr);//设备类型
			if(tempDeviceType != DEVICE_TYPE)//设备类型不对
			{
				err = 0x11;  break;//0x11:设备类型错误
			}

 			if(iDataAddr[tempU16-1]  == 0 )//检测 设置的字符串有没有结束字符
			{
				err = WriteGroupName(iDataAddr[2], &iDataAddr[3], 0x55);// 0x55: 创建组; 0xAA:修改组名;
				if(err == 1)
				{
					needResp = FALSE; //当前不应答
					err = 0x10;  break;//参数错误
				} else {
					ZIGBEE_ASW_PRINTF("pro: cmd:481 -- err: %d.\n",err);
					ackBuf[0] = err;
					ackBuf[1] = iDataAddr[2];//组编号
					ackLen = 2;//应答的数据块长度

					needResp = TRUE; //发送应答
					break;
				}
			} else {
				ackBuf[0] = 0x40;//修改的字符串错误
				ackBuf[1] = iDataAddr[2];//组编号
				ackLen = 2;//应答的数据块长度
				needResp = TRUE; //发送应答
				break;
			}
		}while(0);
	break;
	//---------------------------------
	case 0x0482://删除一个组
		if(pWifiProtocolParm->dataLen != 3)  {  break;  }//数据块 长度错误
		err = 0;//默认结果OK
		do{
			tempDeviceType = wifiProtocol_getDataU16(iDataAddr);//设备类型
			if(tempDeviceType != DEVICE_TYPE)//设备类型不对
			{
				err = 0x11;  break;//0x11:设备类型错误
			}

			if(flashGroupData & ( ((UINT16)0x01)<<iDataAddr[2] ) == 0) //组不存在
			{
				err = 0x13;  break;//0x13:组编号错误
			}

			/* 删除组名 */
			if( 0 != DelGroupName(iDataAddr[2]) )
			{
				err = 0x10;  break;//0x10:参数错误
			}
			
			CheckGroupExist(iDataAddr[2]);//检测场景相关联的组是否存在,不存在就要把该场景删除
			ClearNodeQueryGroupFlag(iDataAddr[2]);//清除属于该组的节点已查询组的标记位

			if(err == 0) 
			{ 
				ackBuf[0] = 0;//操作OK
				ackBuf[1] = iDataAddr[2];//组编号
				ackLen = 2;//应答的数据块长度

				needResp = TRUE; //发送应答
				break;
			} else {
				needResp = FALSE; //当前不应答
				break;//参数错误
			}
		}while(0);
	break;
	//---------------------------------
	case 0x0483://修改组的名字
		tempU16 = pWifiProtocolParm->dataLen;//数据块 长度
		if(tempU16 > 65)  {  break;  }//数据块 长度错误
		err = 0;//默认结果OK
		do{
			tempDeviceType = wifiProtocol_getDataU16(iDataAddr);//设备类型
			if(tempDeviceType != DEVICE_TYPE)//设备类型不对
			{
				err = 0x11;  break;//0x11:设备类型错误
			}

			if(flashGroupData & ( ((UINT16)0x01)<<iDataAddr[2] ) == 0) //组不存在
			{
				err = 0x13;  break;;//0x13:组编号错误
			}
			//如果设置的字符串没有结束字符,要加上
			if( iDataAddr[tempU16-1] ==0 ) 
			{
				err = WriteGroupName(iDataAddr[2], &iDataAddr[3], 0xAA);// 0x55: 创建组; 0xAA:修改组名;
				 if(err == 1)
				{
					needResp = FALSE; //当前不应答
					err = 0x10;  break;//参数错误
				} else {
					ZIGBEE_ASW_PRINTF("pro: err value:%d.\n",err);
					ackBuf[0] = err;
					ackBuf[1] = iDataAddr[2];//组编号
					ackLen = 2;//应答的数据块长度
					needResp = TRUE; //发送应答
					break;
				}
			} else {
				ackBuf[0] = 0x40;//字符串错误
				ackBuf[1] = iDataAddr[2];//组编号
				ackLen = 2;//应答的数据块长度
				needResp = TRUE; //发送应答
				break;
			}
		}while(0);
	break;
	//---------------------------------
	case 0x0484://添加节点到组里
		//if(pWifiProtocolParm->dataLen > 65)  {  break;  }//数据块 长度错误
		err = 0;//默认结果OK
		do{
			tempDeviceType = wifiProtocol_getDataU16(iDataAddr);//设备类型
			if(tempDeviceType != DEVICE_TYPE)//设备类型不对
			{
				err = 0x11;  break;//0x11:设备类型错误
			}

			ZIGBEE_ASW_PRINTF("AddGroupNum: %x.\n", iDataAddr[2]);
			tempU8 = AddNodeToGroup(&iDataAddr[4], iDataAddr[3], iDataAddr[2]);
			if( NODE_NUM_MAX <= tempU8 )
			{
				err = 0x10;  break;//参数错误
			}

			gZigBeeObject.operateGroupFlag = HavaOperateGroup;//上层有对节点组的操作标记
		}while(0);
		if(err == 0)
		{
			ackBuf[0] = 0;//操作OK
			ackBuf[1] = iDataAddr[2];//组编号
			ackBuf[2] = tempU8;//节点添加成功的个数
			ackLen = 3;//应答的数据块长度
			
			needResp = TRUE; //发送应答
		} else {
			needResp = FALSE; //当前不应答
		}
	break;
	//---------------------------------
	case 0x0485://删除组里的节点
		//if(pWifiProtocolParm->dataLen > 65)  {  break;  }//数据块 长度错误
		err = 0;//默认结果OK
		do{
			tempDeviceType = wifiProtocol_getDataU16(iDataAddr);//设备类型
			if(tempDeviceType != DEVICE_TYPE)//设备类型不对
			{
				err = 0x11;  break;//0x11:设备类型错误
			}

			ZIGBEE_ASW_PRINTF("DelGroupNum: %x.\n", iDataAddr[2]);
			tempU8 = DelNodeFromGroup(&iDataAddr[4], iDataAddr[3], iDataAddr[2]);
			if( NODE_NUM_MAX <= tempU8 )
			{
				err = 0x10;  break;//参数错误
			}

			gZigBeeObject.operateGroupFlag = HavaOperateGroup;//上层有对节点组的操作标记
		}while(0);
		if(err == 0)
		{
			ackBuf[0] = 0;//操作OK
			ackBuf[1] = iDataAddr[2];//组编号
			ackBuf[2] = tempU8;//节点删除成功的个数
			ackLen = 3;//应答的数据块长度
			
			needResp = TRUE; //发送应答
		} else {
			needResp = FALSE; //当前不应答
		}
	break;

	//--场景的管理--------------------------------------------------------
	case 0x0500://查询场景信息
		if(pWifiProtocolParm->dataLen != 4)  {  break;  }//数据块 长度错误
		err = 0;//默认结果OK
		do{
			tempDeviceType = wifiProtocol_getDataU16(iDataAddr);//设备类型
			if(tempDeviceType != DEVICE_TYPE)//设备类型不对
			{
				err = 0x11;  break;//0x11:设备类型错误
			}

			ZIGBEE_ASW_PRINTF("Scene:Start:%d.Num:%d.\n", iDataAddr[2], iDataAddr[3]);

			tempU8 = iDataAddr[2];//传入查询组名的开始编号,传出查询的组个数;
			tempU16 = ReadSceneName(&ackBuf[3], &tempU8, (ASW_PROTOCOL_BLOCK_MAX_LEN-3));//读取 场景名
			
			if(tempU16 == 0) 
			{ 
				err = 0x10;  break;//参数错误
			} else {
				ackBuf[0] = 16;//主控设备保存场景的个数.固定为16
				ackBuf[1] = iDataAddr[2];//查询组名的开始编号;
				ackBuf[2] = tempU8;//查询的组个数;
				ackLen = 3 + tempU16;//应答的数据块长度

				ZIGBEE_ASW_PRINTF("pro: groupSceneLen:");
				ZIGBEE_ASW_OUTSTR(&ackBuf[3], 32);
				ZIGBEE_ASW_PRINTF(".\n");
			}
		}while(0);
		if(err == 0)
		{
			needResp = TRUE; //发送应答
		} else {
			needResp = FALSE; //当前不应答
		}
	break;
	//---------------------------------
	case 0x0501://创建一个场景
		tempU16 = pWifiProtocolParm->dataLen;//数据块 长度
		if(pWifiProtocolParm->dataLen > 65)  {  break;  }//数据块 长度错误
		err = 0;//默认结果OK
		do{
			tempDeviceType = wifiProtocol_getDataU16(iDataAddr);//设备类型
			if(tempDeviceType != DEVICE_TYPE)//设备类型不对
			{
				err = 0x11;  break;//0x11:设备类型错误
			}

			if( 0 != GetSceneNameLen(iDataAddr[3]) )//场景已经存在
			{
				err = 0x14;  break;//0x14:参数错误,场景编号错误
			}
			if( 0 != CheckUpGroupNum(iDataAddr[2]) )
			{
				err = 0x15;  break;//0x15:上层要操作的组不属于在线节点的组中.
			}
			if( 0 == (flashGroupData & (((UINT16)0x01)<<iDataAddr[2])) )//组不存在
			{
				err = 0x13;  break;//0x13:组编号错误
			}

			if(BufferEmpty == gUpMsgBuffer.upMsgBufferState)//缓存为空
			{
	 			if(iDataAddr[tempU16-1]  == 0 )//检测 设置的字符串有没有结束字符
				{
					memcpy(gUpMsgBuffer.upDataBlock, iDataAddr, pWifiProtocolParm->dataLen);//缓存数据块
					gUpMsgBuffer.wifiProcotolParm = *pWifiProtocolParm;//wifi协议数据
					gUpMsgBuffer.upMsgBufferState = BufferExist;//有缓存
				}else{//字符串错误
					err = 0x40;
					break;
				}
			}else{
				ZIGBEE_ASW_PRINTF("\n pro: buf Fail.\n");
			}
		}while(0);
		if(err != 0)
		{
			ackBuf[0] = err;
			ackBuf[1] = iDataAddr[2];//组编号
			ackBuf[2] = iDataAddr[3];//场景编号
			ackLen = 3;//应答的数据块长度
			needResp = TRUE; //发送应答
		} else {
			needResp = FALSE; //当前不应答
		}
	break;
	//---------------------------------
	case 0x0502://删除一个场景
		tempU16 = pWifiProtocolParm->dataLen;//数据块 长度
		if(pWifiProtocolParm->dataLen != 4)  {  break;  }//数据块 长度错误
		err = 0;//默认结果OK
		do{
			tempDeviceType = wifiProtocol_getDataU16(iDataAddr);//设备类型
			if(tempDeviceType != DEVICE_TYPE)//设备类型不对
			{
				err = 0x11;  break;//0x11:设备类型错误
			}
			
			if( 0 == CheckGroupExist(iDataAddr[2]) )//检测场景相关联的组是否存在,不存在就要把该场景删除
			{
				err = 0x01;  break;//组不存在了,该场景已无效,直接返回给上层删除成功
			}

			if( 0 == GetSceneNameLen(iDataAddr[3]) )//场景不存在
			{
				err = 0x14;  break;//0x13:参数错误,场景编号错误
			}
			if( flashSceneMatchGroup[iDataAddr[3]] != iDataAddr[2] )//上层发送的组编号跟底层储存的组编号不一致
			{
				err = 0x13;  break;//0x13:组编号错误
			}

			if(BufferEmpty == gUpMsgBuffer.upMsgBufferState)//缓存为空
			{
				memcpy(gUpMsgBuffer.upDataBlock, iDataAddr, pWifiProtocolParm->dataLen);//缓存数据块
				gUpMsgBuffer.wifiProcotolParm = *pWifiProtocolParm;//wifi协议数据
				gUpMsgBuffer.upMsgBufferState = BufferExist;//有缓存
			}else{
				ZIGBEE_ASW_PRINTF("\n pro: buf Fail.\n");
			}
		}while(0);
		if(err != 0)
		{
			if( 0x01 == err ){
				ackBuf[0] = 0;//场景相关联的组不存在了,直接删除了该场景,要提示上层删除成功
			}else{
				ackBuf[0] = err;
			}
			ackBuf[1] = iDataAddr[2];//组编号
			ackBuf[2] = iDataAddr[3];//场景编号
			ackLen = 3;//应答的数据块长度
			needResp = TRUE; //发送应答
		}
	break;
	//---------------------------------
	case 0x0503://修改场景的名字
		tempU16 = pWifiProtocolParm->dataLen;//数据块 长度
		if(tempU16 > 65)  {  break;  }//数据块 长度错误
		err = 0;//默认结果OK
		do{
			tempDeviceType = wifiProtocol_getDataU16(iDataAddr);//设备类型
			if(tempDeviceType != DEVICE_TYPE)//设备类型不对
			{
				err = 0x11;  break;//0x11:设备类型错误
			}

			if( 0 == GetSceneNameLen(iDataAddr[3]) )//场景不存在
			{
				err = 0x14;  break;//0x14:参数错误,场景编号错误
			}
			if( 0 == CheckGroupExist(iDataAddr[2]) )//检测场景相关联的组是否存在,不存在就要把该场景删除
			{
				err = 0x13;  break;//0x13:组编号错误(当成这种错误,毕竟组不存在了,该场景已无效)
			}
			if( flashSceneMatchGroup[iDataAddr[3]] != iDataAddr[2] )//上层发送的组编号跟底层储存的组编号不一致
			{
				err = 0x13;  break;//0x13:组编号错误
			}

			//如果设置的字符串没有结束字符,要加上
			if( iDataAddr[tempU16-1] == 0 ) 
			{
				err = WriteSceneName(iDataAddr[2], iDataAddr[3], &iDataAddr[4], 0xAA);// 0x55: 创建场景; 0xAA:修改场景名;
				 if(err == 1)
				{
					needResp = FALSE; //当前不应答
					err = 0x10;  break;//参数错误
				} else {
					ackBuf[0] = err;
					ackBuf[1] = iDataAddr[2];//组编号
					ackBuf[2] = iDataAddr[3];//场景编号
					ackLen = 3;//应答的数据块长度
					needResp = TRUE; //发送应答
					break;
				}
			} else {
				ackBuf[0] = 0x40;//字符串错误
				ackBuf[1] = iDataAddr[2];//组编号
				ackBuf[2] = iDataAddr[3];//场景编号
				ackLen = 3;//应答的数据块长度
				needResp = TRUE; //发送应答
				break;
			}
		}while(0);
		ZIGBEE_ASW_PRINTF("pro: err value:%d.\n",err);
	break;
	//---------------------------------
	case 0x0504://修改场景(参数)
		if(pWifiProtocolParm->dataLen != 4)  {  break;  }//数据块 长度错误
		err = 0;//默认结果OK
		do{
			tempDeviceType = wifiProtocol_getDataU16(iDataAddr);//设备类型
			if(tempDeviceType != DEVICE_TYPE)//设备类型不对
			{
				err = 0x11;  break;//0x11:设备类型错误
			}

			if( 0 == GetSceneNameLen(iDataAddr[3]) )//场景不存在
			{
				err = 0x14;  break;//0x14:参数错误,场景编号错误
			}
			if( 0 != CheckUpGroupNum(iDataAddr[2]) )
			{
				err = 0x15;  break;//0x15:上层要操作的组不属于在线节点的组中.
			}
			if( 0 == CheckGroupExist(iDataAddr[2]) )//检测场景相关联的组是否存在,不存在就要把该场景删除
			{
				err = 0x13;  break;//0x13:组编号错误(当成这种错误,毕竟组不存在了,该场景已无效)
			}
			if( flashSceneMatchGroup[iDataAddr[3]] != iDataAddr[2] )//上层发送的组编号跟底层储存的组编号不一致
			{
				err = 0x13;  break;//0x13:组编号错误
			}

			if(BufferEmpty == gUpMsgBuffer.upMsgBufferState)//缓存为空
			{
				memcpy(gUpMsgBuffer.upDataBlock, iDataAddr, pWifiProtocolParm->dataLen);//缓存数据块
				gUpMsgBuffer.wifiProcotolParm = *pWifiProtocolParm;//wifi协议数据
				gUpMsgBuffer.upMsgBufferState = BufferExist;//有缓存
			}else{
				ZIGBEE_ASW_PRINTF("\n pro: buf Fail.\n");
			}
		}while(0);
		if(err != 0)
		{
			ackBuf[0] = err;
			ackBuf[1] = iDataAddr[2];//组编号
			ackBuf[2] = iDataAddr[3];//场景编号
			ackLen = 3;//应答的数据块长度
			needResp = TRUE; //发送应答
		} 
	break;
	//---------------------------------
	case 0x0505://操作场景
		if(pWifiProtocolParm->dataLen != 4)  {  break;  }//数据块 长度错误
		err = 0;//默认结果OK
		do{
			tempDeviceType = wifiProtocol_getDataU16(iDataAddr);//设备类型
			if(tempDeviceType != DEVICE_TYPE)//设备类型不对
			{
				err = 0x11;  break;//0x11:设备类型错误
			}

			if( 0 == GetSceneNameLen(iDataAddr[3]) )//场景不存在
			{
				err = 0x14;  break;//0x14:参数错误,场景编号错误
			}
			if( 0 != CheckUpGroupNum(iDataAddr[2]) )
			{
				err = 0x15;  break;//0x15:上层要操作的组不属于在线节点的组中.
			}
			if( 0 == CheckGroupExist(iDataAddr[2]) )//检测场景相关联的组是否存在,不存在就要把该场景删除
			{
				err = 0x13;  break;//0x13:组编号错误(当成这种错误,毕竟组不存在了,该场景已无效)
			}
			if( flashSceneMatchGroup[iDataAddr[3]] != iDataAddr[2] )//上层发送的组编号跟底层储存的组编号不一致
			{
				err = 0x13;  break;//0x13:组编号错误
			}

			if(BufferEmpty == gUpMsgBuffer.upMsgBufferState)//缓存为空
			{
				memcpy(gUpMsgBuffer.upDataBlock, iDataAddr, pWifiProtocolParm->dataLen);//缓存数据块
				gUpMsgBuffer.wifiProcotolParm = *pWifiProtocolParm;//wifi协议数据
				gUpMsgBuffer.upMsgBufferState = BufferExist;//有缓存
			}else{
				ZIGBEE_ASW_PRINTF("\n pro: buf Fail.\n");
			}
		}while(0);
		if(err != 0)
		{
			ackBuf[0] = err;
			ackBuf[1] = iDataAddr[2];//组编号
			ackBuf[2] = iDataAddr[3];//场景编号
			ackLen = 3;//应答的数据块长度
			needResp = TRUE; //发送应答
		} 
	break;

	//--------------------------------------------------------------------
	default:
		ZIGBEE_ASW_PRINTF("deviceZigBee_protocolParse: cmd is err.\n");
	break;
	}

	if(needResp == TRUE)//需要应答信息
	{
		UdpManage_sendData(ackBuf, ackLen, 0, pWifiProtocolParm);
	}

	return;
}

/*****************************************************
* 名称 : deviceZigBee_receUartCommand
* 功能 : wifi模块 与 ZigBee 之间的通讯协议处理.
*
* 参数 : iBuf : in : 串口收到的 ZigBee协议包 首地址;
*        iLen : in : 协议包长度;
* 返回 : 无
*
* 备注 : 1.ZigBee 的 协议 的 开始字符:0x01;  结束字符: 0x03.
*        2. cmd_buf 的 前at_cmd_len个字节 里,不包含 结束字符0x03.
*        3. 除了开始字符 和 结束字符外, 所有小于 0x10的的数据都要
*           进行转义.如: 0x03 => 0x02,0x13. 0x00 => 0x02,0x10.
*           接收到的数据必须先转义,才能按照协议格式进行处理.
*        4. 检验和 (除了 包头, 包尾, 其他所有数据的XOR)(经验的数据
*            是原始数据,不是转义了的数据).
*****************************************************/
void deviceZigBee_receUartCommand(UINT8 *iBuf, UINT16 iLen)
{
	UINT8 *msgAddr,temp;
	UINT16  receCmd;

	if((iBuf == NULL) || (iBuf[0] != 0x01))
	{
		ZIGBEE_ASW_PRINTF("deviceZigBee_receUartCommand : (iBuf == NULL || iBuf[0] != 0x01).\n");
		return;
	}
	if(iLen < 7)
	{
		ZIGBEE_ASW_PRINTF("deviceZigBee_receUartCommand : len < 7.\n");
		return;
	}
	
	//----------- 串口接收协议包处理 -------------
	//转义
	iLen = DecodeEscapeString(iBuf, iLen);
	if(iLen < 7)
	{
		ZIGBEE_ASW_PRINTF("deviceZigBee_receUartCommand : Escape len < 7.\n");
		return;
	}
	//检验和 (除了 包头, 包尾, 其他所有数据的XOR)(经验的数据是原始数据,不是转义了的数据)
	if(0 != CheckSum(iBuf, iLen))
	{
		ZIGBEE_ASW_PRINTF("deviceZigBee_receUartCommand : CheckSum err.\n");
		return;
	}

	gZigBeeObject.receUartTime = GetMsTimer();//接收命令的时间(单位:ms)

//	ZIGBEE_ASW_PRINTF("ZigBee rece:");
//	ZIGBEE_ASW_OUTSTR(iBuf, iLen);

	receCmd = Big_str2uint16(&iBuf[1]);//接收的命令字
	msgAddr = &iBuf[6];

	if( UP_CMD_ADD_NODE == gRespUpBuffer.wifiProcotolParm.cmd )//是允许节点加入的命令的反馈只有协调器的标准应答
	{
		ZIGBEE_ASW_PRINTF("ZB_rece: rCmd: %x.\n", receCmd);
	}else{
		if(0x8000 != receCmd)//控制时不打印协调器反馈的标准应答
		{
			ZIGBEE_ASW_PRINTF("ZB_rece: rCmd: %x.\n", receCmd);
		}
	}
	
	switch(receCmd)
	{
	case 0x8000://标准应答,每条协议包都有这条应答
		gZigBeeObject.cmdAckFlag = msgAddr[0];//发送的每个命令,都会收到0x8000的应答,这个是应答的标志,0:OK.
	break;
	case 0x8030:
		gZigBeeObject.nodeMsgRespType |= (UINT16)Resp_BIND_TYPE;//接收到了绑定的响应消息类型
	break;
	case 0x8041://通过短地址, 获得Ieee地址//01 80 41 00 0E D9 [C3 00 00 15 8D 00 00 36 02 D4 A3 0E 00 00] 03
		AddIeeeAddr(gZigBeeObject.nodeShortAddr, &msgAddr[2]);	
		gZigBeeObject.nodeMsgRespType |= (UINT16)Resp_IEEE_ADDR_TYPE;//接收Ieee地址的标志
	break;
	case 0x8043://获取设备类型的应答//01 80 43 00 27 AF -B7 00 78 A0 22 01 01 04 [01 00] 02 07 00 00 00 04 00 03 00 06 00 08 00 05 FF FF 06 00 00 00 04 00 03 00 06 00 08 00 05 03 
		AddDeviceType(gZigBeeObject.nodeShortAddr, &msgAddr[8]);
		gZigBeeObject.nodeMsgRespType |= (UINT16)Resp_DEVICE_TYPE;
	break;
	case 0x8045://获取节点的通信端口号//01 80 45 00 06 3D -25 00 78 A0 02 [01] 03 
		AddNodeEndPoint(gZigBeeObject.nodeShortAddr, &msgAddr[5]);
		gZigBeeObject.nodeMsgRespType |= (UINT16)Resp_NODE_END_POINT_TYPE;
	break;
	case 0x8046://获得已加入网络的节点信息//01 80 46 00 06 AF C2 00 [A3 0E] 01 [01] 03 
		temp = AddShortAddr(&msgAddr[2], &msgAddr[5]);
		if(0 == temp){//判断是否是新节点加入网络，还是已加入网络的节点重新加入网络
			gZigBeeObject.nodeMsgRespType |= (UINT16)Resp_NEW_NODE_TYPE;//是新节点加入网络
		}
	break;
	case 0x8060://添加节点组地址的应答//01 80 60 00 07 42 -38 01 00 04 8A 00 12 03 
		gZigBeeObject.nodeMsgRespType |= (UINT16)Resp_ADD_GROUP_TYPE;
	break;
	case 0x8062://获取节点组地址的应答//01 80 62 00 0A E0 -0D 01 00 04 [03] [02] [00 00 00 01] 03
		AddGroupAddr(gZigBeeObject.nodeShortAddr, msgAddr[4], msgAddr[5], &msgAddr[6]);
		gZigBeeObject.nodeMsgRespType |= (UINT16)Resp_GET_GROUP_ADDR_TYPE;
	break;
	case 0x8063://删除节点组地址的应答//01 80 63 00 07 BD -58 01 00 04 [00] 00 04 03
		gZigBeeObject.nodeRespStatus = msgAddr[4];//保存操作结果(0x00:success,other:fail)
		gZigBeeObject.nodeMsgRespType |= (UINT16)Resp_REMOVE_GROUP_TYPE;
	break;
	case 0x8100://获取节点状态值的应答//01 81 00 00 09 5D -02 01 [00 08] 00 00 00 20 [FE] 03 
		AddCurrentStateValue(gZigBeeObject.nodeShortAddr, &msgAddr[2], &msgAddr[8]);
		gZigBeeObject.nodeMsgRespType |= (UINT16)Resp_STATE_VALUE_TYPE;
	break;
	case 0x8101://控制LED节点OK的默认应答
		gZigBeeObject.nodeMsgRespType |= (UINT16)Resp_NODE_DEFAULT_TYPE;
	break;
	case 0x004D://新节点加入网络的Announce应答//01 00 4D 00 0B 21 -[78 A0] [00 15 8D 00 00 7B F1 23] 8E 03 
		if( 0xFFFF == Big_str2uint16(&msgAddr[0]) )
		{
			vSaveControllerInfo(&msgAddr[2]);
		}else{
			temp = AddNewNodeAddr(&msgAddr[0],&msgAddr[2]);
		
			if(0 == temp){//判断是否是新节点加入网络，还是已加入网络的节点重新加入网络
				gZigBeeObject.nodeMsgRespType |= (UINT16)Resp_NEW_NODE_TYPE;//是新节点加入网络
			}else if(1 == temp){//检测是旧节点
				gZigBeeObject.flushNodeFlag = FlushNodeState;//刷新节点状态标记
			}	
		}
	break;
	default:
	break;
	}
}

/**************************************************************
* 名称 : deviceZigBee_getNodeNum
* 功能 : 获得 ZigBee的节点数目。
*
* 参数 : pAckData     : out : 打包好的协议数据块数据;
*        iMAC         :  in : 从机的MAC地址(5字节);
*        iPwm         :  in : 设置 的 PWM值;
* 返回 : len          :  打包后,协议的长度; 0:err;
*
* 备注 : 1.
**************************************************************/
UINT8  deviceZigBee_GetNodeNum(void)
{
	return(GetNodeNum());//全部节点数
}

/**************************************************************
* 名称 : QueryStateMachine
* 功能 : 查询状态机.
*
* 参数 : 无
* 返回 : 无
*
* 备注 : 1.常态状态机，没有接收到上层命令时的常时运行的状态机
**************************************************************/
void QueryStateMachine(void)
{
	static UINT32  		flushNodeTime = 0;//刷新节点间隔
	static UINT32  		intervalTime = 0;//待机间隔基准时间
	static UINT32  		groupTime = 0;//组操作间隔基准时间
	UINT32   			tempTime;
 
	tempTime = GetMsTimer();
	switch(gZigBeeObject.state)
	{
	case ZIGBEE_INIT://网络初始化
		if(SUB_STATE_END == ModelInitState())
		{
			StateJump(ZIGBEE_OBTAIN_SHORT_ADDR);
 		}
	break;
	case ZIGBEE_OBTAIN_SHORT_ADDR://获取节点短地址
		if(SUB_STATE_END == ObtainShortAddrState())
		{
			flushNodeTime = tempTime;//刷新节点间隔
			StateJump(ZIGBEE_QUERY_NODE_ATTR);
 		}
	break;
	case ZIGBEE_QUERY_NODE_ATTR://查询节点相关属性
		if(SUB_STATE_END == QueryNodeAttrState())
		{
			StateJump(ZIGBEE_QUERY_NODE_STATE);
 		}
	break;
	case ZIGBEE_QUERY_NODE_STATE://查询节点状态
		if(SUB_STATE_END == QueryNodeState())
		{
			intervalTime = tempTime;//查询节点状态待机间隔
			gZigBeeObject.flushNodeFlag = ClearFlushFlag;//清除刷新节点状态标记
			StateJump(ZIGBEE_QUERY_GROUP_ADDR);
 		}
	break;
	case ZIGBEE_QUERY_GROUP_ADDR://查询节点组地址
		if(SUB_STATE_END == QueryGroupAddrState())
		{
			groupTime = tempTime;//查询节点状态待机间隔
			gZigBeeObject.operateGroupFlag = ClearOperateFlag;//清除上层有对组的操作的标记
			StateJump(ZIGBEE_INTERVAL_TIME);
 		}
	break;
	case ZIGBEE_INTERVAL_TIME://待机状态		
		if((UINT16)Resp_NEW_NODE_TYPE == (gZigBeeObject.nodeMsgRespType & ((UINT16)Resp_NEW_NODE_TYPE)))//接收到了新节点响应的Announce消息,跳转
		{	
			gZigBeeObject.nodeMsgRespType &= ( ~((UINT16)Resp_NEW_NODE_TYPE) );//清除新节点加入的节点响应消息类型标记
			StateJump(ZIGBEE_QUERY_NODE_ATTR);//查询节点相关属性
		}else if(gZigBeeObject.flushNodeFlag == FlushNodeState){//刷新节点状态标记
			StateJump(ZIGBEE_QUERY_NODE_STATE);//查询节点状态
		}else if(gZigBeeObject.operateGroupFlag == HavaOperateGroup){
			StateJump(ZIGBEE_QUERY_GROUP_ADDR);//查询节点组地址
		}else{
			if((tempTime -flushNodeTime) > 30uL*60uL*1000uL)//待机30分钟，跳转到获取节点短地址
			{ 
				ClearNodeAllFlag();//清除节点的所有标记位,让节点重新获取所有数据.
				StateJump(ZIGBEE_OBTAIN_SHORT_ADDR);//获取节点短地址
			}
			if((tempTime -intervalTime) > 30uL*1000uL)//待机30秒
			{
				StateJump(ZIGBEE_QUERY_NODE_ATTR);//查询节点相关属性
			}
			if((tempTime -groupTime) > 10uL*1000uL)//待机10秒
			{
				StateJump(ZIGBEE_QUERY_GROUP_ADDR);//查询节点组地址
			}
		}
	break;
	default:
		StateJump(ZIGBEE_INIT);
	break;
	}
}

/**************************************************************
* 名称 : ModelInitState
* 功能 : ZigBee模块初始化.
*
* 参数 : 无
* 返回 : 无
*
* 备注 : 1. 
**************************************************************/
SubState_BackFlag ModelInitState(void)
{
	SubState_BackFlag    outFlag;
	UINT32   			 tempTime;
	
	outFlag  = SUB_STATE_RUN;//默认此状态运行
	tempTime = GetMsTimer();
	switch(gZigBeeObject.sequence)
	{
	case 0://初始化
		gZigBeeObject.sequence = 1;
	break;
	case 1:
		SendUartCommand(cmd11, sizeof(cmd11));//发送命令11
		gZigBeeObject.sequence = 2;
	break;
	case 2:
		if(gZigBeeObject.cmdAckFlag == 0)//协调器有应答
		{
			if((tempTime - gZigBeeObject.receUartTime) > 1000){//等待接收, 不判断
				gZigBeeObject.sequence = 3;
			}
		}else if((tempTime - gZigBeeObject.sendCmdTime) > 2000){//2秒超时
			gZigBeeObject.sequence = 0;//重新复位
		}
	break;
	case 3:    SendUartCommand(cmd12, sizeof(cmd12));    gZigBeeObject.sequence = 4;  break;//发送 命令12
	case 5:    SendUartCommand(cmd13, sizeof(cmd13));    gZigBeeObject.sequence = 6;  break;//发送 命令13
	case 7:    SendUartCommand(cmd14, sizeof(cmd14));    gZigBeeObject.sequence = 8;  break;//发送 命令14
	case 9:    SendUartCommand(cmd15, sizeof(cmd15));    gZigBeeObject.sequence = 10; break;//发送 命令15
	case 11:   SendUartCommand(cmd16, sizeof(cmd16));    gZigBeeObject.sequence = 12; break;//发送 命令16

	case 4:  case 6:  case 8:  case 10: case 12://对命令应答的处理
		if(gZigBeeObject.cmdAckFlag != 0xFF)
		{
			if((gZigBeeObject.cmdAckFlag == 0) && ((tempTime - gZigBeeObject.receUartTime) > 10))//收到应答后,再等待10ms
			{
				gZigBeeObject.sequence ++; 
			}
			if(gZigBeeObject.cmdAckFlag != 0)
			{
				ZIGBEE_ASW_PRINTF("ModelInitState : cmdAckFlag err. val:%d.\n",gZigBeeObject.cmdAckFlag);
				gZigBeeObject.sequence = 0; //重新复位
			}
		} else if((tempTime - gZigBeeObject.sendCmdTime) > 2000) {//2秒超时
			gZigBeeObject.sequence = 0; //重新复位
		}
	break;
	case 13:
		gZigBeeObject.ableCtrlFlag = AllowCtrl ;//0xF0,允许上层发送控制命令
		outFlag = SUB_STATE_END;
	break;
	default:
		gZigBeeObject.sequence = 0; //重新复位
	break;
	}

	return(outFlag);
}

/**************************************************************
* 名称 : ObtainShortAddrState
* 功能 : 获取已经在ZigBee网络的节点短地址
* 参数 : 无
* 返回 : 无
*
* 备注 :1.cmd21的应答: 01 80 46 00 06 BD D0 00 A3 0E 01 01 03 (有效数据为: A3 0E 01 01) 
 *	     A3 0E 01 01   --[A3 0E] 节点短地址 ，最后一位的[01] 表示通信端口号
**************************************************************/
 SubState_BackFlag ObtainShortAddrState(void)
{
	SubState_BackFlag    outFlag;
	UINT32   tempTime;
	
	outFlag  = SUB_STATE_RUN;//默认此状态运行
	tempTime = GetMsTimer();
	switch(gZigBeeObject.sequence)
	{
	case 0x00://初始化 
		gZigBeeObject.sequence = 0x01;
	break;
	case 0x01:
		SendUartCommand(cmd21, sizeof(cmd21));//发送命令21
		gZigBeeObject.sequence = 0x02;  
	break;
	case 0x02:
		if((tempTime - gZigBeeObject.receUartTime) > 300){//300ms超时
			gZigBeeObject.sequence = 0xF0;
		}
	break;
	case 0xF0:
		gZigBeeObject.ableCtrlFlag = AllowCtrl;//允许进入控制状态标记
		outFlag = SUB_STATE_END;//退出此状态
	break;
	default:
		gZigBeeObject.sequence = 0;//重新发送cmd21
	break;
	}
	
	return(outFlag);
}

/**************************************************************
* 名称 : QueryNodeAttrState
* 功能 : 查询节点相关属性
*
* 参数 : 无
* 返回 : 无
*
* 备注 : 1.GetAttrQueryNumber()--获得信息漏缺的节点编号.
*        2.GetAttrQueryNumber()的参数:输入起始编号是为了避免该节点一直没响应，却一直在查该节点的现象产生,若该节点没响应，则跳到下一个节点。
*	    3.根据整个状态机的运转过程，Ieee(EndPoint) -> DevType -> NodeAttr，查漏时，实行优先级策略，
*          及优先查询该节点的信息是否漏缺了Ieee地址,再查EndPoint通信端口号,以此类推.
**************************************************************/
SubState_BackFlag QueryNodeAttrState(void)
{
	SubState_BackFlag    outFlag;
	UCHAR    pCmdBuf[32];
	UINT32   tempTime;
	
	outFlag  = SUB_STATE_RUN;
	tempTime = GetMsTimer();
	switch(gZigBeeObject.sequence)
	{
	case 0x00://初始化
		gNodeQueryNumber = 0;
		gZigBeeObject.sequence = 0x01;
	break;
	case 0x01:
		gNodeQueryNumber = GetAttrQueryNumber(gNodeQueryNumber);
		
		if(NODE_NUM_MAX <= gNodeQueryNumber){
 			gZigBeeObject.sequence = 0xF0;//属性查询完成，此状态完成，跳出
		}else{
			gZigBeeObject.sequence = 0x10;//节点的属性不完整
		}
	break;
	//-----------------------------------------------------------------------
	case 0x10://查询Ieee地址属性
		if( 0 == ((gZigBeeObject.gNodeInfo[gNodeQueryNumber].nodeIndicate) & ((UINT8)NODE_OBTAIN_IEEE_ADDR_FLAG)) )
		{
			memcpy(pCmdBuf, cmd31, sizeof(cmd31));//拷贝cmd31

			Big_uint16ToStr(&pCmdBuf[6], gZigBeeObject.gNodeInfo[gNodeQueryNumber].shortAddr);
			Big_uint16ToStr(&pCmdBuf[8], gZigBeeObject.gNodeInfo[gNodeQueryNumber].shortAddr);

			gZigBeeObject.nodeShortAddr = gZigBeeObject.gNodeInfo[gNodeQueryNumber].shortAddr;//临时保存当前查询的节点短地址，以备接收节点响应时知道是哪个节点

			gZigBeeObject.nodeMsgRespType &= ( ~((UINT16)Resp_IEEE_ADDR_TYPE) );//接收Ieee地址的消息响应类型
			SendUartCommand(pCmdBuf, sizeof(cmd31));//发送命令31
			
			gZigBeeObject.sequence = 0x11;
		} else {
			gZigBeeObject.sequence = 0x20;//该节点已查询Ieee地址属性,查看该节点是否需要查询通信端口号属性
		}
	break;
	case 0x11:
		if((gZigBeeObject.nodeMsgRespType & ((UINT16)Resp_IEEE_ADDR_TYPE)) && ((tempTime - gZigBeeObject.receUartTime) > 10))//收到应答后,再等待10ms
		{
			gZigBeeObject.ableCtrlFlag = AllowCtrl;//允许进入控制状态标记
			gZigBeeObject.sequence = 0x20;//查询完了Ieee地址属性，查看该节点是否没有查询通信端口号属性
		}else if((tempTime - gZigBeeObject.sendCmdTime) > 500){//500ms超时
			gZigBeeObject.ableCtrlFlag = AllowCtrl;//允许进入控制状态标记
 			gZigBeeObject.sequence = 0xE0;//超时没有接收该节点的响应消息，则查询下一个节点(没有Ieee地址属性，其他属性都不要查询了，查询了也没用)
		}
	break;
	//--------------------------------------------------------------------------
	case 0x20://查询节点通信端口号属性
		if( 0 == ((gZigBeeObject.gNodeInfo[gNodeQueryNumber].nodeIndicate) & ((UINT8)NODE_OBTAIN_END_POINT_FLAG)) )
		{
			memcpy(pCmdBuf,cmd32,sizeof(cmd32));
			Big_uint16ToStr(&pCmdBuf[6], gZigBeeObject.gNodeInfo[gNodeQueryNumber].shortAddr);

			gZigBeeObject.nodeShortAddr = gZigBeeObject.gNodeInfo[gNodeQueryNumber].shortAddr;//临时保存当前查询的节点短地址，以备接收节点响应时知道是哪个节点

			gZigBeeObject.nodeMsgRespType &= ( ~((UINT16)Resp_NODE_END_POINT_TYPE) );//接收通信端口号的标志
			SendUartCommand(pCmdBuf, sizeof(cmd32));//发送命令32

			gZigBeeObject.sequence = 0x21;
		}else{
			gZigBeeObject.sequence = 0x30;//该节点已查询通信端口号,查看该节点是否需要查询设备类型属性
		}
	break;
	case 0x21:
		if((gZigBeeObject.nodeMsgRespType & ((UINT16)Resp_NODE_END_POINT_TYPE)) && ((tempTime - gZigBeeObject.receUartTime) > 10))
		{
			gZigBeeObject.ableCtrlFlag = AllowCtrl;//允许进入控制状态标记
			gZigBeeObject.sequence = 0x30;//查询完通信端口号属性,查看该节点是否需要查询设备类型属性
		}else if((tempTime - gZigBeeObject.sendCmdTime) > 500){//500ms超时
			gZigBeeObject.ableCtrlFlag = AllowCtrl;//允许进入控制状态标记
 			gZigBeeObject.sequence = 0xE0;//查询下一个节点
		}
	break;
	//--------------------------------------------------------------------------
	case 0x30://查询节点设备类型属性
		if( 0 == ((gZigBeeObject.gNodeInfo[gNodeQueryNumber].nodeIndicate) & ((UINT8)NODE_OBTAIN_DEV_TYPE_FLAG)) )
		{
			memcpy(pCmdBuf, cmd33, sizeof(cmd33));//拷贝cmd33

			Big_uint16ToStr(&pCmdBuf[6], gZigBeeObject.gNodeInfo[gNodeQueryNumber].shortAddr);
			pCmdBuf[8] = gZigBeeObject.gNodeInfo[gNodeQueryNumber].endPoint;

			gZigBeeObject.nodeShortAddr = gZigBeeObject.gNodeInfo[gNodeQueryNumber].shortAddr;//临时保存当前查询的节点短地址，以备接收节点响应时知道是哪个节点
		
			gZigBeeObject.nodeMsgRespType &= ( ~((UINT16)Resp_DEVICE_TYPE) );//接收设备类型的消息响应类型
			SendUartCommand(pCmdBuf, sizeof(cmd33));//发送命令33

			gZigBeeObject.sequence = 0x31;
		}else{
			gZigBeeObject.sequence = 0xE0;//该节点已查询设备类型属性,则查询下一个节点的属性
		}
	break;
	case 0x31:
		if(((gZigBeeObject.nodeMsgRespType & ((UINT16)Resp_DEVICE_TYPE)) && ((tempTime - gZigBeeObject.receUartTime) > 10)) ||
		    ((tempTime - gZigBeeObject.sendCmdTime) > 500))//500ms超时
		{
			gZigBeeObject.ableCtrlFlag = AllowCtrl;//允许进入控制状态标记
 			gZigBeeObject.sequence = 0xE0;//查询下一个节点
		}
	break;
	//----------------------------------------------------------------------
	case 0xE0://查询下一个节点
		gNodeQueryNumber += 1;
 		gZigBeeObject.sequence = 0x01;//查询下一个节点的信息
	break;
	case 0xF0:
		outFlag = SUB_STATE_END;
	break;
	default:
		gZigBeeObject.sequence = 0x00; //出错
	break;
	}

	return(outFlag);
}

/**************************************************************
* 名称 : QueryGroupAddrState
* 功能 : 查询节点组地址
* 参数 : 无
* 返回 : 无
*
* 备注 :1.cmd62的应答: 01 80 62 00 0A E0 0D [01] 00 04 03 02 [00 00 00 01] 03
*		01 -- 指定端口
*	     00 00 00 01   --[00 00] 组地址1 ，-- [00 01] 组地址2
**************************************************************/
 SubState_BackFlag QueryGroupAddrState(void)
{
	SubState_BackFlag    outFlag;
	UCHAR    pCmdBuf[32];
	UINT16     tempGroupList;//保存要操作的组列表(位为1 的表)
	static UINT16  sGroupAddr;//静态保存添加一个组或者删除一个组时操作的组地址
	
	UINT32   tempTime;
	
	outFlag  = SUB_STATE_RUN;//默认此状态运行
	tempTime = GetMsTimer();
	switch(gZigBeeObject.sequence)
	{
	case 0x00://初始化
		gNodeQueryNumber = 0;
		gZigBeeObject.sequence = 0x01;
	break;
	case 0x01:
		sGroupAddr = 0xFFFF;//初始化为0xFFFF(因为每个节点都可能使用,所以得放在该处初始化)
		gNodeQueryNumber = GetGroupQueryNumber(gNodeQueryNumber);
		
		if(NODE_NUM_MAX <= gNodeQueryNumber){
 			gZigBeeObject.sequence = 0xF0;//查询完成，跳出
		}else{
			gZigBeeObject.sequence = 0x02;
		}
	break;
	case 0x02://获取节点指定端口所在的组地址
		/* 真实 vs 虚的 */
		if(gZigBeeObject.gNodeInfo[gNodeQueryNumber].nodeGroupAddr == gZigBeeObject.gNodeInfo[gNodeQueryNumber].upGroupAddr)
		{//zigbeeGroup 和 upGroup 一样 (真实跟虚的一样)
			memcpy(pCmdBuf, cmd62, sizeof(cmd62));//拷贝cmd62
			Big_uint16ToStr(&pCmdBuf[7], gZigBeeObject.gNodeInfo[gNodeQueryNumber].shortAddr);	
			pCmdBuf[10] = gZigBeeObject.gNodeInfo[gNodeQueryNumber].endPoint;

			gZigBeeObject.nodeShortAddr = gZigBeeObject.gNodeInfo[gNodeQueryNumber].shortAddr;//临时保存当前查询的节点短地址，以备接收节点响应时知道是哪个节点

			gZigBeeObject.nodeMsgRespType &= ( ~((UINT16)Resp_GET_GROUP_ADDR_TYPE) );//接收组地址的消息响应类型
			SendUartCommand(pCmdBuf, sizeof(cmd62));//发送命令62

			gZigBeeObject.sequence = 0x03;
		}else{//zigbeeGroup 和 upGroup 不一样 (真实跟虚的不一样)
			gZigBeeObject.sequence = 0x10;
		}
	break;
	case 0x03://等待子节点的响应消息
		if( (gZigBeeObject.nodeMsgRespType & ((UINT16)Resp_GET_GROUP_ADDR_TYPE)) && ((tempTime - gZigBeeObject.receUartTime) > 10) ) //收到应答后,再等待10ms
		{
			gZigBeeObject.ableCtrlFlag = AllowCtrl;//允许进入控制状态标记
 			gZigBeeObject.sequence = 0x10;
		}else if((tempTime - gZigBeeObject.sendCmdTime) > 500){//500ms超时
			gZigBeeObject.ableCtrlFlag = AllowCtrl;//允许进入控制状态标记
			gZigBeeObject.sequence = 0xE0;//操作下一个节点
		}
	break;

	//-------------------------------------------------------------------------------------
	case 0x10://判断节点是否存在无效组地址(无效:协议通讯没有使用的组地址)
		if( 0x0000 != gNodeInvalidGroup[0] ){
			memcpy(pCmdBuf, cmd63, sizeof(cmd63));
			Big_uint16ToStr(&pCmdBuf[7], gNodeInvalidGroup[0]);
			pCmdBuf[10] = gZigBeeObject.gNodeInfo[gNodeQueryNumber].endPoint;
			Big_uint16ToStr(&pCmdBuf[11], gNodeInvalidGroup[1]);
			
			gZigBeeObject.nodeMsgRespType &= ( ~((UINT16)Resp_REMOVE_GROUP_TYPE) );//接收设备状态的消息响应类型
			SendUartCommand(pCmdBuf, sizeof(cmd63));

			gZigBeeObject.sequence = 0x11;
		}else{
			gZigBeeObject.sequence = 0x20;
		}
	break;
	case 0x11://等待子节点的响应消息
		if((gZigBeeObject.nodeMsgRespType & ((UINT16)Resp_REMOVE_GROUP_TYPE)) && ((tempTime - gZigBeeObject.receUartTime) > 10)){//接收到了控制节点OK的消息，并且应答后延时10ms	
			if(0x00 == gZigBeeObject.nodeRespStatus){//组地址删除成功
				gNodeInvalidGroup[0] = 0x0000;//表明该无效组地址已删除,清空无效数据.
			}
			gZigBeeObject.ableCtrlFlag = AllowCtrl;//允许进入控制状态标记
			gZigBeeObject.sequence = 0x20;
		}else if((tempTime - gZigBeeObject.sendCmdTime) > 500){//500ms超时
			gZigBeeObject.ableCtrlFlag = AllowCtrl;//允许进入控制状态标记
			gZigBeeObject.sequence = 0x20;
		}
	break;

	//---------------------------------------------------------------------------------------
	case 0x20://查看该节点是否跟flash的组地址数据一样,不一样就得删除多余的组
		tempGroupList = (gZigBeeObject.gNodeInfo[gNodeQueryNumber].nodeGroupAddr) & (~flashGroupData);//取出节点多余的所有组地址
		if( 0x0000 != tempGroupList )
		{
			tempGroupList = tempGroupList & ( ~(tempGroupList -1) );//多余的组可能有几种情况,本处算法是取出其中一种情况:tempGroupList:0000 0011 换算后0000 0010或者0000 0001

			memcpy(pCmdBuf, cmd63, sizeof(cmd63));
			Big_uint16ToStr(&pCmdBuf[7], gZigBeeObject.gNodeInfo[gNodeQueryNumber].shortAddr);
			pCmdBuf[10] = gZigBeeObject.gNodeInfo[gNodeQueryNumber].endPoint;
			Big_uint16ToStr(&pCmdBuf[11], tempGroupList);
			
			gZigBeeObject.nodeMsgRespType &= ( ~((UINT16)Resp_REMOVE_GROUP_TYPE) );//接收设备状态的消息响应类型
			SendUartCommand(pCmdBuf, sizeof(cmd63));

			gZigBeeObject.sequence = 0x21;
		}else{//节点真实组地址在flashGroupData数据之内,没有错误
			gZigBeeObject.gNodeInfo[gNodeQueryNumber].upGroupAddr = (gZigBeeObject.gNodeInfo[gNodeQueryNumber].upGroupAddr) & flashGroupData;//冗余操作.确保虚的组地址数据在flashGroupData之内
			gZigBeeObject.sequence = 0x22;
		}
	break;
	case 0x21://等待子节点的响应消息
		if( (gZigBeeObject.nodeMsgRespType & ((UINT16)Resp_REMOVE_GROUP_TYPE)) && ((tempTime - gZigBeeObject.receUartTime) > 10) ) //收到应答后,再等待10ms
		{
			gZigBeeObject.ableCtrlFlag = AllowCtrl;//允许进入控制状态标记
			gZigBeeObject.sequence = 0x30;//更新节点的组地址信息
		}else if((tempTime - gZigBeeObject.sendCmdTime) > 500){//500ms超时
			gZigBeeObject.ableCtrlFlag = AllowCtrl;//允许进入控制状态标记
			gZigBeeObject.gNodeInfo[gNodeQueryNumber].nodeIndicate &= ( ~((UINT16)NODE_OBTAIN_GROUP_ADDR_FLAG) );//冗余操作,确保下次会再次操作该节点
			gZigBeeObject.sequence = 0xE0;//操作下一个节点
		}
	break;

	//-------------------------------
	case 0x22://删除节点指定端口的指定组
		ZIGBEE_ASW_PRINTF("QGAS: upGroup:%x,zbGroup:%x.\n", gZigBeeObject.gNodeInfo[gNodeQueryNumber].upGroupAddr, gZigBeeObject.gNodeInfo[gNodeQueryNumber].nodeGroupAddr);
		/* 取出需要删除的组地址 下一行解决的问题 zb:1100,add:0001(fail),del:0100.那么up:1001,下一行算法则能取出需要删除的0100组以及之前没有操作成功的组出来 */
		tempGroupList = ( (gZigBeeObject.gNodeInfo[gNodeQueryNumber].upGroupAddr) |(gZigBeeObject.gNodeInfo[gNodeQueryNumber].nodeGroupAddr) ) & ( ~(gZigBeeObject.gNodeInfo[gNodeQueryNumber].upGroupAddr) );

		if( 0x0000 != tempGroupList )
		{//该节点需要删除组地址
			ZIGBEE_ASW_PRINTF("\n--------------------------------------\n");
			ZIGBEE_ASW_PRINTF("QGAS: Node[%d]: -Del Group.\n", gNodeQueryNumber);

			tempGroupList = tempGroupList & ( ~(tempGroupList -1) );//得出的数据可能还包含了以前没有设置成功的组,本处算法是取出其中一种情况: 0011 换算后0001
			
			memcpy(pCmdBuf, cmd63, sizeof(cmd63));
			Big_uint16ToStr(&pCmdBuf[7], gZigBeeObject.gNodeInfo[gNodeQueryNumber].shortAddr);
			pCmdBuf[10] = gZigBeeObject.gNodeInfo[gNodeQueryNumber].endPoint;
			Big_uint16ToStr(&pCmdBuf[11], tempGroupList);
			
			sGroupAddr = tempGroupList;//静态保存本次操作的组地址
			gZigBeeObject.nodeMsgRespType &= ( ~((UINT16)Resp_REMOVE_GROUP_TYPE) );//接收设备状态的消息响应类型
			SendUartCommand(pCmdBuf, sizeof(cmd63));

			gZigBeeObject.sequence = 0x23;
		}else{//该节点不需要删除组地址
			gZigBeeObject.sequence = 0x24;
		}
	break;
	case 0x23://等待子节点的响应消息
		if( (gZigBeeObject.nodeMsgRespType & ((UINT16)Resp_REMOVE_GROUP_TYPE)) && ((tempTime - gZigBeeObject.receUartTime) > 10) )//收到应答后,再等待10ms
		{
			gZigBeeObject.ableCtrlFlag = AllowCtrl;//允许进入控制状态标记
			gZigBeeObject.sequence = 0x30;//更新节点的组地址信息
		}else if((tempTime - gZigBeeObject.sendCmdTime) > 500){//500ms超时
			gZigBeeObject.ableCtrlFlag = AllowCtrl;//允许进入控制状态标记
			gZigBeeObject.gNodeInfo[gNodeQueryNumber].nodeIndicate &= ( ~((UINT16)NODE_OBTAIN_GROUP_ADDR_FLAG) );//冗余操作,确保下次会再次操作该节点
			gZigBeeObject.sequence = 0xE0;
		}
	break;
	
	//-------------------------------
	case 0x24://添加节点的指定端口到组中
		ZIGBEE_ASW_PRINTF("QGAS: upGroup:%x,zbGroup:%x.\n", gZigBeeObject.gNodeInfo[gNodeQueryNumber].upGroupAddr, gZigBeeObject.gNodeInfo[gNodeQueryNumber].nodeGroupAddr);
		/* 取出需要添加的组地址 下一行解决的问题 zb:1101,del:0001(fail),add:0010.那么up:1110,下一行算法则能取出需要添加的0010以及之前没有操作成功的组出来 */
		tempGroupList = ( (gZigBeeObject.gNodeInfo[gNodeQueryNumber].upGroupAddr) |(gZigBeeObject.gNodeInfo[gNodeQueryNumber].nodeGroupAddr) ) & ( ~(gZigBeeObject.gNodeInfo[gNodeQueryNumber].nodeGroupAddr) );
		
		if( 0x0000 != tempGroupList )
		{//该节点需要添加组地址
			ZIGBEE_ASW_PRINTF("\n--------------------------------------\n");
			ZIGBEE_ASW_PRINTF("QGAS: Node[%d]: -Add Group.\n", gNodeQueryNumber);

			tempGroupList = tempGroupList & ( ~(tempGroupList -1) );//得出的数据可能还包含了以前没有设置成功的组,本处算法是取出其中一种情况:0011 换算后0001

			memcpy(pCmdBuf, cmd61, sizeof(cmd61));
			Big_uint16ToStr(&pCmdBuf[7], gZigBeeObject.gNodeInfo[gNodeQueryNumber].shortAddr);
			pCmdBuf[10] = gZigBeeObject.gNodeInfo[gNodeQueryNumber].endPoint;
			Big_uint16ToStr(&pCmdBuf[11], tempGroupList);

			sGroupAddr = tempGroupList;//静态保存本次操作的组地址
			gZigBeeObject.nodeMsgRespType &= ( ~((UINT16)Resp_ADD_GROUP_TYPE) );//接收设备状态的消息响应类型
			SendUartCommand(pCmdBuf, sizeof(cmd61));

			gZigBeeObject.sequence = 0x25;
		}else{//该节点不需要添加组地址
			gZigBeeObject.gNodeInfo[gNodeQueryNumber].nodeIndicate |= NODE_OBTAIN_GROUP_ADDR_FLAG;
			gZigBeeObject.sequence = 0xE0;
		}
	break;
	case 0x25://等待子节点的响应消息
		if( (gZigBeeObject.nodeMsgRespType & ((UINT16)Resp_ADD_GROUP_TYPE)) && ((tempTime - gZigBeeObject.receUartTime) > 10) )//收到应答后,再等待10ms
		{
			gZigBeeObject.ableCtrlFlag = AllowCtrl;//允许进入控制状态标记
			gZigBeeObject.sequence = 0x30;//更新节点的组地址信息
		}else if((tempTime - gZigBeeObject.sendCmdTime) > 500){//500ms超时
			gZigBeeObject.ableCtrlFlag = AllowCtrl;//允许进入控制状态标记
			gZigBeeObject.gNodeInfo[gNodeQueryNumber].nodeIndicate &= ( ~((UINT16)NODE_OBTAIN_GROUP_ADDR_FLAG) );//冗余操作,确保下次会再次操作该节点
			gZigBeeObject.sequence = 0xE0;
		}
	break;

	//-------------------------------------------------------------------------------------
	case 0x30://操作了节点的组地址之后,需要及时更新节点的组地址信息到结构体中
		memcpy(pCmdBuf, cmd62, sizeof(cmd62));//拷贝cmd62
		Big_uint16ToStr(&pCmdBuf[7], gZigBeeObject.gNodeInfo[gNodeQueryNumber].shortAddr);	
		pCmdBuf[10] = gZigBeeObject.gNodeInfo[gNodeQueryNumber].endPoint;

		gZigBeeObject.nodeShortAddr = gZigBeeObject.gNodeInfo[gNodeQueryNumber].shortAddr;//临时保存当前查询的节点短地址，以备接收节点响应时知道是哪个节点

		gZigBeeObject.nodeMsgRespType &= ( ~((UINT16)Resp_GET_GROUP_ADDR_TYPE) );//接收组地址的消息响应类型
		SendUartCommand(pCmdBuf, sizeof(cmd62));//发送命令62

		gZigBeeObject.sequence = 0x31;
	break;
	case 0x31://等待子节点的响应消息
		if( (gZigBeeObject.nodeMsgRespType & ((UINT16)Resp_GET_GROUP_ADDR_TYPE)) && ((tempTime - gZigBeeObject.receUartTime) > 10) ) //收到应答后,再等待10ms
		{
			gZigBeeObject.ableCtrlFlag = AllowCtrl;//允许进入控制状态标记
 			gZigBeeObject.sequence = 0x32;
		}else if((tempTime - gZigBeeObject.sendCmdTime) > 500){//500ms超时
			gZigBeeObject.ableCtrlFlag = AllowCtrl;//允许进入控制状态标记
			gZigBeeObject.sequence = 0xE0;//操作下一个节点
		}
	break;
	case 0x32://添加与删除操作,执行成功之后,查询组地址发现结果没变,需要抹掉节点的虚拟的与真实的组地址的不同的该位
		if( 1 == CountBitUint(sGroupAddr) )
		{//判断变量不等于初始化的值0xFF,且只有一位为1,表面前方有添加组操作或者是删除组操作
			if( 0 == (gZigBeeObject.gNodeInfo[gNodeQueryNumber].nodeGroupAddr & sGroupAddr) )
			{//前面操作的是添加组的操作
				gZigBeeObject.gNodeInfo[gNodeQueryNumber].upGroupAddr  &= (~sGroupAddr);
			}else{//前面操作的是删除组的操作
				gZigBeeObject.gNodeInfo[gNodeQueryNumber].upGroupAddr  |= sGroupAddr;
			}
		}
		gZigBeeObject.sequence = 0x33;
	break;
	case 0x33://判断真实的跟虚的数据结果,对节点的查询组地址的标记位做不同的操作.如果相同,标记为已查询,如果不同,清除该标记位(不管之前有没有清除)
		if(gZigBeeObject.gNodeInfo[gNodeQueryNumber].upGroupAddr == gZigBeeObject.gNodeInfo[gNodeQueryNumber].nodeGroupAddr)
		{//真实的跟虚的数据一样
			gZigBeeObject.gNodeInfo[gNodeQueryNumber].nodeIndicate |= (UINT8)NODE_OBTAIN_GROUP_ADDR_FLAG;
		}else{//不一样
			gZigBeeObject.gNodeInfo[gNodeQueryNumber].nodeIndicate &= (~(UINT8)NODE_OBTAIN_GROUP_ADDR_FLAG);
		}
		gZigBeeObject.sequence = 0xE0;
	break;
	
	//----------------------------------------------------------------------
	case 0xE0://查询下一个节点
		gNodeQueryNumber += 1;
 		gZigBeeObject.sequence = 0x01;//查询下一个节点
	break;
	case 0xF0:
		outFlag = SUB_STATE_END;
	break;
	default:
		gZigBeeObject.sequence = 0x00; //出错
	break;
	}
	
	return(outFlag);
}

/**************************************************************
* 名称 : QueryNodeState
* 功能 : 查询节点状态值.
*
* 参数 : 无
* 返回 : 无
*
* 备注 : 1.包括开关状态,显示的亮度值,色温值
**************************************************************/
SubState_BackFlag QueryNodeState(void)
{
	SubState_BackFlag    outFlag;
	UCHAR    pCmdBuf[32];
	UINT32   tempTime;
	
	outFlag  = SUB_STATE_RUN;
	tempTime = GetMsTimer();
	switch(gZigBeeObject.sequence)
	{
	/************避免出现节点假不在线和假在线 现象************************/
	case 0x00://初始化
		gNodeQueryNumber = 0;
		gZigBeeObject.sequence = 0x0A;
	break;
 	case 0x0A:
		gZigBeeObject.nodeShortAddr = 0;
		memcpy(pCmdBuf, cmd41, sizeof(cmd41));//拷贝 cmd41
		SendUartCommand(pCmdBuf, sizeof(cmd41));//发送命令41
		gZigBeeObject.sequence = 0x02;
	break;
	case 0x02:
		if((tempTime - gZigBeeObject.receUartTime) > 100)//应答后延时150ms
		{
			gZigBeeObject.ableCtrlFlag = AllowCtrl;//允许进入控制状态标记
			gZigBeeObject.sequence = 0x03;
		}
	break;
	case 0x03:
		memcpy(pCmdBuf, cmd41, sizeof(cmd41));//拷贝 cmd41
		SendUartCommand(pCmdBuf, sizeof(cmd41));//发送命令41
		gZigBeeObject.sequence = 0x04;
	break;
	case 0x04:
		if((tempTime - gZigBeeObject.receUartTime) > 100)//应答后延时10ms
		{
			gZigBeeObject.ableCtrlFlag = AllowCtrl;//允许进入控制状态标记
			gNodeQueryNumber = 0;
			gZigBeeObject.sequence = 0x01;
		}
	break;
	/******************************************************************/
	case 0x01:
		gNodeQueryNumber = GetStateQueryNumber(gNodeQueryNumber);

		if(NODE_NUM_MAX <= gNodeQueryNumber){
 			gZigBeeObject.sequence = 0xF0;//查询完成，跳出
		}else{
			gZigBeeObject.sequence = 0x10;
		}
	break;
 
	//-----------------------------------------------------------------------
 	case 0x10://判别不同节点类型，执行不同LED灯的状态获取过程
		if(LIGHT_COLOUR_CTRL == (gZigBeeObject.gNodeInfo[gNodeQueryNumber].deviceType)){
			gZigBeeObject.sequence = 0x20;
		}else if(LIGHT_LEVEL_CTRL == (gZigBeeObject.gNodeInfo[gNodeQueryNumber].deviceType)){
			gZigBeeObject.sequence = 0x30;
		}else if(LIGHT_ONOFF_CTRL== (gZigBeeObject.gNodeInfo[gNodeQueryNumber].deviceType)){
			gZigBeeObject.sequence = 0x40;
		}else{
			ZIGBEE_ASW_PRINTF("devType err: %x.\n", gZigBeeObject.gNodeInfo[gNodeQueryNumber].deviceType);
			gZigBeeObject.sequence = 0xE0;//设备类型错误，查询下一个节点
		}
	break;
	//------------ 色温 ---------------------------
	case 0x20://可控色温的LED灯的色温状态值的获取
		memcpy(pCmdBuf, cmd41, sizeof(cmd41));//拷贝 cmd41
		Big_uint16ToStr(&pCmdBuf[7], gZigBeeObject.gNodeInfo[gNodeQueryNumber].shortAddr);
		pCmdBuf[10] = gZigBeeObject.gNodeInfo[gNodeQueryNumber].endPoint;
		
		gZigBeeObject.nodeShortAddr = gZigBeeObject.gNodeInfo[gNodeQueryNumber].shortAddr;//临时保存当前查询的节点短地址，以备接收节点响应时知道是哪个节点
	
		Big_uint16ToStr(&pCmdBuf[11], CLUSTER_ID_COLOUR_CTRL);
		pCmdBuf[19] = 0x07;//色温属性的获取,在节点属性的色温属性编号后两位是07

		gZigBeeObject.nodeMsgRespType &= ( ~((UINT16)Resp_STATE_VALUE_TYPE) );//接收设备状态的消息响应类型
		SendUartCommand(pCmdBuf, sizeof(cmd41));//发送命令41
		
		gZigBeeObject.sequence = 0x21;
	break;
	case 0x21:
		if(((UINT16)Resp_STATE_VALUE_TYPE) == (gZigBeeObject.nodeMsgRespType & ((UINT16)Resp_STATE_VALUE_TYPE)))//接收到了节点状态值的消息，并且应答后延时10ms
		{
			if((tempTime - gZigBeeObject.receUartTime) > 10)//应答后延时10ms
			{
				gZigBeeObject.ableCtrlFlag = AllowCtrl;//允许进入控制状态标记
				gZigBeeObject.sequence = 0x30;//查询灯的亮度等级状态
			}
		}else if((tempTime - gZigBeeObject.sendCmdTime) > 500){//500ms超时
			if( 0 == gZigBeeObject.cmdAckFlag )//协调器收到了查询状态的命令的反馈
			{
				gZigBeeObject.gNodeInfo[gNodeQueryNumber].nodeIndicate &= (~(UINT8)NODE_OBTAIN_ONLINE_FLAG);//0xFE超时没有接收响应,表明节点不在线 
			}
			gZigBeeObject.ableCtrlFlag = AllowCtrl;//允许进入控制状态标记
			gZigBeeObject.sequence = 0x30;
		}
	break;
	//----------  可控亮度  -----------------
	case 0x30://可控亮度的LED亮度状态值获取
		memcpy(pCmdBuf, cmd41, sizeof(cmd41));//拷贝 cmd41
		Big_uint16ToStr(&pCmdBuf[7], gZigBeeObject.gNodeInfo[gNodeQueryNumber].shortAddr);
		pCmdBuf[10] = gZigBeeObject.gNodeInfo[gNodeQueryNumber].endPoint;
	
		gZigBeeObject.nodeShortAddr = gZigBeeObject.gNodeInfo[gNodeQueryNumber].shortAddr;//临时保存当前查询的节点短地址，以备接收节点响应时知道是哪个节点
	
		Big_uint16ToStr(&pCmdBuf[11], CLUSTER_ID_LEVEL_CTRL);

		gZigBeeObject.nodeMsgRespType &= ( ~((UINT16)Resp_STATE_VALUE_TYPE) );//接收设备状态的消息响应类型
		SendUartCommand(pCmdBuf, sizeof(cmd41));//发送命令41
		
		gZigBeeObject.sequence = 0x31;
	break;
	case 0x31:
		if( ((UINT16)Resp_STATE_VALUE_TYPE) == (gZigBeeObject.nodeMsgRespType & ((UINT16)Resp_STATE_VALUE_TYPE)) )//接收到了节点状态值的消息
		{
			if((tempTime - gZigBeeObject.receUartTime) > 10)//应答后延时10ms
			{
				gZigBeeObject.ableCtrlFlag = AllowCtrl;//允许进入控制状态标记
				gZigBeeObject.sequence = 0x40;//查询节点的开关状态
			}
		}else if((tempTime - gZigBeeObject.sendCmdTime) > 500){ //500ms超时
			if( 0 == gZigBeeObject.cmdAckFlag )//协调器收到了查询状态的命令的反馈
			{
				gZigBeeObject.gNodeInfo[gNodeQueryNumber].nodeIndicate &= (~(UINT8)NODE_OBTAIN_ONLINE_FLAG);//0xFE超时没有接收响应,表明节点不在线 
			}
			gZigBeeObject.ableCtrlFlag = AllowCtrl;//允许进入控制状态标记
			gZigBeeObject.sequence = 0xE0;
		}
	break;
	//----------- 开关 ---------------------
	case 0x40://开关状态的获取
		memcpy(pCmdBuf, cmd41, sizeof(cmd41));//拷贝 cmd41
		Big_uint16ToStr(&pCmdBuf[7], gZigBeeObject.gNodeInfo[gNodeQueryNumber].shortAddr);
		pCmdBuf[10] = gZigBeeObject.gNodeInfo[gNodeQueryNumber].endPoint;
	
		gZigBeeObject.nodeShortAddr = gZigBeeObject.gNodeInfo[gNodeQueryNumber].shortAddr;//临时保存当前查询的节点短地址，以备接收节点响应时知道是哪个节点
	
		Big_uint16ToStr(&pCmdBuf[11], CLUSTER_ID_ONOFF_CTRL);
		
		gZigBeeObject.nodeMsgRespType &= ( ~((UINT16)Resp_STATE_VALUE_TYPE) );//接收设备状态的消息响应类型
		SendUartCommand(pCmdBuf, sizeof(cmd41));//发送命令41
		
		gZigBeeObject.sequence = 0x41;
	break;
	case 0x41:
		if(((UINT16)Resp_STATE_VALUE_TYPE) == (gZigBeeObject.nodeMsgRespType & ((UINT16)Resp_STATE_VALUE_TYPE)))//接收到了节点状态值的消息
		{
			if((tempTime - gZigBeeObject.receUartTime) > 10)//应答后延时10ms
			{
				gZigBeeObject.ableCtrlFlag = AllowCtrl;//允许进入控制状态标记
				gZigBeeObject.sequence = 0xE0;
			}
		}else if((tempTime - gZigBeeObject.sendCmdTime) > 500){//500ms超时
			if( 0 == gZigBeeObject.cmdAckFlag )//协调器收到了查询状态的命令的反馈
			{
				gZigBeeObject.gNodeInfo[gNodeQueryNumber].nodeIndicate &= (~(UINT8)NODE_OBTAIN_ONLINE_FLAG);//0xFE超时没有接收响应,表明节点不在线 
			}
			gZigBeeObject.ableCtrlFlag = AllowCtrl;//允许进入控制状态标记
			gZigBeeObject.sequence = 0xE0;
		} else {
			//没有收到信息,还没有超时,不做处理
		}
	break;

	//----------------------------------------------------------------------
	case 0xE0://查询下一个节点
		gNodeQueryNumber += 1;
 		gZigBeeObject.sequence = 0x01;//查询下一个节点
 	break;
	//--------------------------------
	case 0xF0:
		outFlag = SUB_STATE_END;
	break;
	default:
		gZigBeeObject.sequence = 0x00; //出错
	break;
	}
	
	return(outFlag);
}

/**************************************************************
* 名称 : ControlNodeState
* 功能 : 执行上层发送的控制命令并反馈数据给上层
*
* 参数 : 无
* 返回 : 无
*
* 备注 : 1.
**************************************************************/
//出错的出错源标记 -- errSource
/*   0x00:OK, 0x01:协调器没响应, 0x02:节点没响应, 0x12:没有匹配的地址
*/	    
SubState_BackFlag ControlNodeState(void)
{
	static UINT8	errSource;
	SubState_BackFlag    outFlag;
	
	uint8_t    ackBuf[ASW_PROTOCOL_MAX_LEN]={0};
	uint16_t  ackLen;
	
	UCHAR   	pCmdBuf[32];
	UINT8   	tempNodeNum = 0;
	UINT16	tempGroupAddr;
	UINT32  	tempTime;
	
	outFlag  = SUB_STATE_RUN;
	tempTime = GetMsTimer();

	switch(gZigBeeObject.ctrlSequence)
	{
	case 0x00://初始化
		errSource = 0x00;//默认没有出错
		gZigBeeObject.ctrlSequence = 0x01;
	break;
	case 0x01://判断缓存命令类型，再执行相应操作
		if(gUpMsgBuffer.wifiProcotolParm.cmd == UP_CMD_ADD_NODE){//添加新节点加入网络的一级命令
 			gZigBeeObject.ctrlSequence = 0x10;
		}else if(gUpMsgBuffer.wifiProcotolParm.cmd == UP_CMD_GROUP_CTRL)
		{//组控
			if(gUpMsgBuffer.upDataBlock[5] == UP_SUB_CMD_ONOFF){//控制开关状态的二级命令
				gZigBeeObject.ctrlSequence = 0x20;
			}else if(gUpMsgBuffer.upDataBlock[5] == UP_SUB_CMD_LEVEL){//控制亮度等级的二级命令
				gZigBeeObject.ctrlSequence = 0x30;
			}else if(gUpMsgBuffer.upDataBlock[5] == UP_SUB_CMD_COLOUR){//控制色温的二级命令
				gZigBeeObject.ctrlSequence = 0x40;
			}else{
				ZIGBEE_ASW_PRINTF("CtrlNodeS: Up_Sub_CmdType err: %x.\n", gUpMsgBuffer.upDataBlock[5]);
				gZigBeeObject.ctrlSequence = 0x02;
			}
		}else if(gUpMsgBuffer.wifiProcotolParm.cmd == UP_CMD_SHORT_CTRL)
		{//单控
			if( CONTROLLER_DEV_TYPE == gUpMsgBuffer.upDataBlock[10] )
			{
				if(gUpMsgBuffer.upDataBlock[12] == UP_SUB_CMD_BIND )//绑定遥控器和节点
				{
					gZigBeeObject.ctrlSequence = 0x80;
				}
			}else{
				if(gUpMsgBuffer.upDataBlock[12] == UP_SUB_CMD_ONOFF){//控制开关状态的二级命令
				gZigBeeObject.ctrlSequence = 0x20;
				}else if(gUpMsgBuffer.upDataBlock[12] == UP_SUB_CMD_LEVEL){//控制亮度等级的二级命令
					gZigBeeObject.ctrlSequence = 0x30;
				}else if(gUpMsgBuffer.upDataBlock[12] == UP_SUB_CMD_COLOUR){//控制色温的二级命令
					gZigBeeObject.ctrlSequence = 0x40;
				}else{
					ZIGBEE_ASW_PRINTF("CtrlNodeS: Up_Sub_CmdType err: %x.\n", gUpMsgBuffer.upDataBlock[12]);
					gZigBeeObject.ctrlSequence = 0x02;
				}
			}
			
		}else if(gUpMsgBuffer.wifiProcotolParm.cmd == UP_CMD_CREATE_SCENE){//创建一个新场景
			gZigBeeObject.ctrlSequence = 0x50;
		}else if(gUpMsgBuffer.wifiProcotolParm.cmd == UP_CMD_CHANGE_SCENE){//修改场景(覆盖原有场景,所有是同样的操作)
			gZigBeeObject.ctrlSequence = 0x50;
		}else if(gUpMsgBuffer.wifiProcotolParm.cmd == UP_CMD_DEL_SCENE){//删除一个场景
			gZigBeeObject.ctrlSequence = 0x60;
		}else if(gUpMsgBuffer.wifiProcotolParm.cmd == UP_CMD_RECALL_SCENE){//操作场景(恢复场景)
			gZigBeeObject.ctrlSequence = 0x70;
		}else{
			ZIGBEE_ASW_PRINTF("CtrlNodeS: UpCmdType err: %x.\n", gUpMsgBuffer.wifiProcotolParm.cmd);
			gZigBeeObject.ctrlSequence = 0x02;
		}
	break;
	case 0x02://处理出错跳转到此状态
		gZigBeeObject.ctrlSequence = 0xF0;
	break;
	
	//--------------------------------------------------------------------
	case 0x10://允许新节点加入网络命令
		memcpy(pCmdBuf, cmd71, sizeof(cmd71));
		SendUartCommand(pCmdBuf, sizeof(cmd71));

		gRespUpBuffer.wifiProcotolParm = gUpMsgBuffer.wifiProcotolParm;//保存wifi协议数据，不被清除
		gUpMsgBuffer.upMsgBufferState = BufferEmpty;//标记缓存为空
		gZigBeeObject.ctrlSequence = 0x11;
	break;
	case 0x11://等待协调器响应(只适用运行新节点加入命令后的等待操作)
		if( (0x00 == gZigBeeObject.cmdAckFlag) && ((tempTime - gZigBeeObject.receUartTime) > 10) ){
			gZigBeeObject.ctrlSequence = 0xE1;
		}else if( (tempTime - gZigBeeObject.sendCmdTime) > 500 ){ //500ms超时
			errSource = 0x01;//协调器没响应
			gZigBeeObject.ctrlSequence = 0x12;	
		}  
	break;
	case 0x12://处理出错跳转到此状态
		gZigBeeObject.ctrlSequence = 0xE1;
	break;
	
	//-------------------------------------------------------------------
	case 0x20://控制开关状态的二级命令
		memcpy(pCmdBuf, cmd72, sizeof(cmd72));
		
		if(gUpMsgBuffer.wifiProcotolParm.cmd == UP_CMD_SHORT_CTRL)
		{//单控
			tempNodeNum = SearchNode(&gUpMsgBuffer.upDataBlock[2]);
			if( NODE_NUM_MAX <= tempNodeNum )
			{
				errSource = 0x12;//没有匹配的短地址
				gZigBeeObject.ctrlSequence = 0x22;	
				break;
			}

			Big_uint16ToStr(&pCmdBuf[7], gZigBeeObject.gNodeInfo[tempNodeNum].shortAddr);
			pCmdBuf[10] = gZigBeeObject.gNodeInfo[tempNodeNum].endPoint;

			if( 0x55 == gUpMsgBuffer.upDataBlock[13]){//打开
				pCmdBuf[11] = 0x01;
			}else{
				pCmdBuf[11] = 0x00;
			}
			
		}else{//组控
			pCmdBuf[6] = 0x01;//组控模式
				
			tempGroupAddr = ((UINT16)0x01) << gUpMsgBuffer.upDataBlock[2];
			Big_uint16ToStr(&pCmdBuf[7], tempGroupAddr);
			/* 组控可以忽略端口号 */
			//pCmdBuf[10] = 0x01;
			if( 0x55 == gUpMsgBuffer.upDataBlock[6]){//打开
				pCmdBuf[11] = 0x01;
			}else{
				pCmdBuf[11] = 0x00;
			}
		}
		
		gZigBeeObject.nodeMsgRespType &= ( (~(UINT16)Resp_NODE_DEFAULT_TYPE) );//接收设备状态的消息响应类型
		SendUartCommand(pCmdBuf, sizeof(cmd72));
		
		gRespUpBuffer.wifiProcotolParm = gUpMsgBuffer.wifiProcotolParm;//保存wifi协议数据，不被清除
		memcpy(gRespUpBuffer.upDataBlock, gUpMsgBuffer.upDataBlock, gUpMsgBuffer.wifiProcotolParm.dataLen);//保存协议数据中的数据块
		gUpMsgBuffer.upMsgBufferState = BufferEmpty;//标记缓存为空
		gZigBeeObject.ctrlSequence = 0x21;
	break;
	case 0x21://等待子节点的控制响应消息
		if(UP_CMD_SHORT_CTRL == gUpMsgBuffer.wifiProcotolParm.cmd) //单控
		{
			if((gZigBeeObject.nodeMsgRespType & ((UINT16)Resp_NODE_DEFAULT_TYPE)) && ((tempTime - gZigBeeObject.receUartTime) > 10)){//接收到了控制节点OK的消息，并且应答后延时10ms	
				gZigBeeObject.ctrlSequence = 0xE0;
			}else if((tempTime - gZigBeeObject.sendCmdTime) > 500){//500ms超时
				if(gZigBeeObject.cmdAckFlag == 0x00){
					errSource = 0x02;//节点没响应
				}else if(gZigBeeObject.cmdAckFlag == 0xFF){
					errSource = 0x01;//协调器没响应
				}
				gZigBeeObject.ctrlSequence = 0x22;
			}
		}else{ //组控 -- 组控的响应只有协调器的status消息,没有节点的响应消息
			if( (gZigBeeObject.cmdAckFlag == 0x00) && ((tempTime - gZigBeeObject.receUartTime) > 10) ){//接收到了协调器的status消息，并且应答后延时10ms
				gZigBeeObject.ctrlSequence = 0xE0;
			}else if( (tempTime - gZigBeeObject.sendCmdTime) > 300 ){//300ms超时
				errSource = 0x01;//协调器没响应
				gZigBeeObject.ctrlSequence = 0x22;
			}
		}
	break;
	case 0x22://处理出错跳转到此状态
		gZigBeeObject.ctrlSequence = 0xE0;
	break;

	//--------------------------------------------------------------------
	case 0x30://控制亮度等级命令
		if(gUpMsgBuffer.wifiProcotolParm.cmd == UP_CMD_SHORT_CTRL)
		{//单控
			/* 匹配短地址 */
			tempNodeNum = SearchNode(&gUpMsgBuffer.upDataBlock[2]);
			if( NODE_NUM_MAX <= tempNodeNum )
			{
				errSource = 0x12;//没有匹配的短地址
				gZigBeeObject.ctrlSequence = 0x32;	
				break;
			}

			/* 判断是关灯开灯,还是调节亮度 */
			if( 0x00 == gUpMsgBuffer.upDataBlock[13] )
			{//关灯需要发关灯指令
				memcpy(pCmdBuf, cmd72, sizeof(cmd72));

				Big_uint16ToStr(&pCmdBuf[7], gZigBeeObject.gNodeInfo[tempNodeNum].shortAddr);
				pCmdBuf[10] = gZigBeeObject.gNodeInfo[tempNodeNum].endPoint;

				pCmdBuf[11] = 0x00;//关掉灯
				gZigBeeObject.nodeMsgRespType &= ( ~((UINT16)Resp_NODE_DEFAULT_TYPE) );//接收设备状态的消息响应类型
				SendUartCommand(pCmdBuf,sizeof(cmd72));
			}else{//调节亮度等级
				memcpy(pCmdBuf,cmd73,sizeof(cmd73));

				Big_uint16ToStr(&pCmdBuf[7], gZigBeeObject.gNodeInfo[tempNodeNum].shortAddr);
				pCmdBuf[10] = gZigBeeObject.gNodeInfo[tempNodeNum].endPoint;

				/* 此处待定,0xFF是开灯,应发开灯指令 */
				if(0xFF == gUpMsgBuffer.upDataBlock[13]){
					pCmdBuf[12] = 0xFE;
				}else{
					pCmdBuf[12] = gUpMsgBuffer.upDataBlock[13];
				}

				gZigBeeObject.nodeMsgRespType &= ( ~((UINT16)Resp_NODE_DEFAULT_TYPE) );//接收设备状态的消息响应类型
				SendUartCommand(pCmdBuf,sizeof(cmd73));
			}
		}else{//组控
			/* 判断是关灯开灯,还是调节亮度 */
			if( 0x00 == gUpMsgBuffer.upDataBlock[6] )
			{//关灯需要发关灯指令
				memcpy(pCmdBuf, cmd72, sizeof(cmd72));

				pCmdBuf[6] = 0x01;//组控模式
				tempGroupAddr = ((UINT16)0x01) << gUpMsgBuffer.upDataBlock[2];
				Big_uint16ToStr(&pCmdBuf[7], tempGroupAddr);
				/* 组控可以忽略端口号 */
				//pCmdBuf[10] = 0x01;//端口号
				pCmdBuf[11] = 0x00;//关掉灯
				
				gZigBeeObject.nodeMsgRespType &= ( ~((UINT16)Resp_NODE_DEFAULT_TYPE) );//接收设备状态的消息响应类型
				SendUartCommand(pCmdBuf,sizeof(cmd72));
			}else{//调节亮度等级
				memcpy(pCmdBuf,cmd73,sizeof(cmd73));

				pCmdBuf[6] = 0x01;//组控模式
				tempGroupAddr = ((UINT16)0x01) << gUpMsgBuffer.upDataBlock[2];
				Big_uint16ToStr(&pCmdBuf[7], tempGroupAddr);
				/* 组控可以忽略端口号 */
				//pCmdBuf[10] = 0x01;//端口号
				
				/* 此处待定,0xFF是开灯,应发开灯指令 */
				if(0xFF == gUpMsgBuffer.upDataBlock[6]){
					pCmdBuf[12] = 0xFE;
				}else{
					pCmdBuf[12] = gUpMsgBuffer.upDataBlock[6];
				}

				gZigBeeObject.nodeMsgRespType &= ( ~((UINT16)Resp_NODE_DEFAULT_TYPE) );//接收设备状态的消息响应类型
				SendUartCommand(pCmdBuf,sizeof(cmd73));
			}
		}
	
		gRespUpBuffer.wifiProcotolParm = gUpMsgBuffer.wifiProcotolParm;//保存wifi协议数据，不被清除
		memcpy(gRespUpBuffer.upDataBlock, gUpMsgBuffer.upDataBlock, gUpMsgBuffer.wifiProcotolParm.dataLen);//保存协议数据中的数据块
		gUpMsgBuffer.upMsgBufferState = BufferEmpty;//标记缓存为空
		gZigBeeObject.ctrlSequence = 0x31;
	break;
	case 0x31://等待子节点的控制响应消息
		if( UP_CMD_SHORT_CTRL == gUpMsgBuffer.wifiProcotolParm.cmd ) //单控
		{
			if((gZigBeeObject.nodeMsgRespType & ((UINT16)Resp_NODE_DEFAULT_TYPE)) && ((tempTime - gZigBeeObject.receUartTime) > 10)){//接收到了控制节点OK的消息，并且应答后延时10ms	
				gZigBeeObject.ctrlSequence = 0xE0;
			}else if((tempTime - gZigBeeObject.sendCmdTime) > 500){ //500ms超时
				if(gZigBeeObject.cmdAckFlag == 0x00){
					errSource = 0x02;//节点没响应
				}else if(gZigBeeObject.cmdAckFlag == 0xFF){
					errSource = 0x01;//协调器没响应
				}
				gZigBeeObject.ctrlSequence = 0x32;
			}
		}else{ //组控 -- 组控的响应只有协调器的status消息,没有节点的响应消息
			if( (gZigBeeObject.cmdAckFlag == 0x00) && ((tempTime - gZigBeeObject.receUartTime) > 10) ){//接收到了协调器的status消息，并且应答后延时10ms
				gZigBeeObject.ctrlSequence = 0xE0;
			}else if( (tempTime - gZigBeeObject.sendCmdTime) > 300 ){//300ms超时
				errSource = 0x01;//协调器没响应
				gZigBeeObject.ctrlSequence = 0x32;
			}
		}
	break;
	case 0x32://处理出错跳转到此状态
		gZigBeeObject.ctrlSequence = 0xE0;
	break;
	
	//--------------------------------------------------------------------
	case 0x40://控制色温的命令
		memcpy(pCmdBuf, cmd74, sizeof(cmd74));

		/* 是组控还是单控 */
		if(gUpMsgBuffer.wifiProcotolParm.cmd == UP_CMD_SHORT_CTRL)
		{	
			/* 匹配短地址 */
			tempNodeNum = SearchNode(&gUpMsgBuffer.upDataBlock[2]);
			if( NODE_NUM_MAX <= tempNodeNum )
			{
				errSource = 0x12;//没有匹配的短地址
				gZigBeeObject.ctrlSequence = 0x42;	
				break;
			}

			Big_uint16ToStr(&pCmdBuf[7], gZigBeeObject.gNodeInfo[tempNodeNum].shortAddr);
			pCmdBuf[10] = gZigBeeObject.gNodeInfo[tempNodeNum].endPoint;

			/* 转换上层发送的色温控制值,发送给Zigbee节点*/
			if( 0xD8 < gUpMsgBuffer.upDataBlock[13] ){
				Big_uint16ToStr(&pCmdBuf[11], 0x0172);//0xD8 = 216,协议色温值:0 - 216 , 实际色温程序设置值:154 - 370
			}else{//0x00即 0x9A, 0x9A = 154,色温值以154为基准
				Big_uint16ToStr(&pCmdBuf[11], ((UINT16)gUpMsgBuffer.upDataBlock[13] + 0x009A));
			}
		}else{
			pCmdBuf[6] = 0x01;//组控模式
			tempGroupAddr = ((UINT16)0x01) << gUpMsgBuffer.upDataBlock[2];
			Big_uint16ToStr(&pCmdBuf[7], tempGroupAddr);
			/* 组控可以忽略端口号 */
			//pCmdBuf[10] = 0x01;//端口号

			/* 转换上层发送的色温控制值,发送给Zigbee节点*/
			if( 0xD8 < gUpMsgBuffer.upDataBlock[6] ){
				Big_uint16ToStr(&pCmdBuf[11], 0x0172);//0xD8 = 216,协议色温值:0 - 216 , 实际色温程序设置值:154(0x009A) - 370(0x0172)
			}else{//0x00即 0x9A, 0x9A = 154,色温值以154为基准
				Big_uint16ToStr(&pCmdBuf[11], ((UINT16)gUpMsgBuffer.upDataBlock[6] + 0x009A));
			}
		}

		gZigBeeObject.nodeMsgRespType &= ( ~((UINT16)Resp_NODE_DEFAULT_TYPE) );//接收设备状态的消息响应类型
		SendUartCommand(pCmdBuf, sizeof(cmd74));

		gRespUpBuffer.wifiProcotolParm = gUpMsgBuffer.wifiProcotolParm;//保存wifi协议数据，不被清除
		memcpy(gRespUpBuffer.upDataBlock, gUpMsgBuffer.upDataBlock, gUpMsgBuffer.wifiProcotolParm.dataLen);//保存协议数据中的数据块
		gUpMsgBuffer.upMsgBufferState = BufferEmpty;//标记缓存为空
		gZigBeeObject.ctrlSequence = 0x41;
	break;
	case 0x41://等待子节点的控制响应消息
		if( UP_CMD_SHORT_CTRL == gUpMsgBuffer.wifiProcotolParm.cmd ) //单控
		{
			if((gZigBeeObject.nodeMsgRespType & ((UINT16)Resp_NODE_DEFAULT_TYPE)) && ((tempTime - gZigBeeObject.receUartTime) > 10)){//接收到了控制节点OK的消息，并且应答后延时10ms	
				gZigBeeObject.ctrlSequence = 0xE0;
			}else if((tempTime - gZigBeeObject.sendCmdTime) > 500){ //500ms超时
				if(gZigBeeObject.cmdAckFlag == 0x00){
					errSource = 0x02;//节点没响应
				}else if(gZigBeeObject.cmdAckFlag == 0xFF){
					errSource = 0x01;//协调器没响应
				}
				gZigBeeObject.ctrlSequence = 0x42;
			}
		}else{ //组控 -- 组控的响应只有协调器的status消息,没有节点的响应消息
			if( (gZigBeeObject.cmdAckFlag == 0x00) && ((tempTime - gZigBeeObject.receUartTime) > 10) ){//接收到了协调器的status消息，并且应答后延时10ms
				gZigBeeObject.ctrlSequence = 0xE0;
			}else if( (tempTime - gZigBeeObject.sendCmdTime) > 300 ){//300ms超时
				errSource = 0x01;//协调器没响应
				gZigBeeObject.ctrlSequence = 0x42;
			}
		}
	break;
	case 0x42://处理出错跳转到此状态
		gZigBeeObject.ctrlSequence = 0xE0;
	break;

	//-----------------------------------------------------------------------------
	case 0x50://创建一个新场景或者修改场景(覆盖已有场景)
		memcpy(pCmdBuf, cmd75, sizeof(cmd75));

		tempGroupAddr = ((UINT16)0x01) << gUpMsgBuffer.upDataBlock[2];
		Big_uint16ToStr(&pCmdBuf[7], tempGroupAddr);//组地址
		Big_uint16ToStr(&pCmdBuf[11], tempGroupAddr);//组ID
		pCmdBuf[13] = gUpMsgBuffer.upDataBlock[3];//场景ID

		SendUartCommand(pCmdBuf, sizeof(cmd75));

		gRespUpBuffer.wifiProcotolParm = gUpMsgBuffer.wifiProcotolParm;//保存wifi协议数据，不被清除
		memcpy(gRespUpBuffer.upDataBlock, gUpMsgBuffer.upDataBlock, gUpMsgBuffer.wifiProcotolParm.dataLen);//保存协议数据中的数据块
		gUpMsgBuffer.upMsgBufferState = BufferEmpty;//标记缓存为空
		gZigBeeObject.ctrlSequence = 0x51;
	break;
	case 0x51://等待协调器响应(只适用运行新节点加入命令后的等待操作)
		if( (0x00 == gZigBeeObject.cmdAckFlag) && ((tempTime - gZigBeeObject.receUartTime) > 10) ){
			gZigBeeObject.ctrlSequence = 0x52;//操作成功
		}else if( (tempTime - gZigBeeObject.sendCmdTime) > 500 ){ //500ms超时
			errSource = 0x01;//协调器没响应
			gZigBeeObject.ctrlSequence = 0x53;	//操作失败
		}
	break;
	case 0x52://操作成功后要保存场景相关数据到Flash
		if(gRespUpBuffer.wifiProcotolParm.cmd == UP_CMD_CREATE_SCENE){//创建 场景
			errSource = WriteSceneName(gRespUpBuffer.upDataBlock[2], gRespUpBuffer.upDataBlock[3], &gRespUpBuffer.upDataBlock[4], 0x55);
		}else{//修改场景(参数)
			//不做处理
		}
		
		gZigBeeObject.ctrlSequence = 0xE2;
	break;
	case 0x53://处理出错跳转到此状态
		gZigBeeObject.ctrlSequence = 0xE2;
	break;
	//--------------------------------------
	case 0x60://删除一个场景
		memcpy(pCmdBuf, cmd76, sizeof(cmd76));

		tempGroupAddr = ((UINT16)0x01) << gUpMsgBuffer.upDataBlock[2];
		Big_uint16ToStr(&pCmdBuf[7], tempGroupAddr);//组地址
		Big_uint16ToStr(&pCmdBuf[11], tempGroupAddr);//组ID
		pCmdBuf[13] = gUpMsgBuffer.upDataBlock[3];//场景ID

		SendUartCommand(pCmdBuf, sizeof(cmd76));

		gRespUpBuffer.wifiProcotolParm = gUpMsgBuffer.wifiProcotolParm;//保存wifi协议数据，不被清除
		memcpy(gRespUpBuffer.upDataBlock, gUpMsgBuffer.upDataBlock, gUpMsgBuffer.wifiProcotolParm.dataLen);//保存协议数据中的数据块
		gUpMsgBuffer.upMsgBufferState = BufferEmpty;//标记缓存为空
		gZigBeeObject.ctrlSequence = 0x61;
	break;
	case 0x61://等待协调器响应(只适用运行新节点加入命令后的等待操作)
		if( (0x00 == gZigBeeObject.cmdAckFlag) && ((tempTime - gZigBeeObject.receUartTime) > 10) ){
			gZigBeeObject.ctrlSequence = 0x62;//操作成功
		}else if( (tempTime - gZigBeeObject.sendCmdTime) > 500 ){ //500ms超时
			errSource = 0x01;//协调器没响应
			gZigBeeObject.ctrlSequence = 0x63;	//操作失败
		}
	break;
	case 0x62://操作成功后要从Flash中删除场景相关数据
		errSource = DelSceneName(gRespUpBuffer.upDataBlock[3]);
		
		gZigBeeObject.ctrlSequence = 0xE2;
	break;
	case 0x63://处理出错跳转到此状态
		gZigBeeObject.ctrlSequence = 0xE2;
	break;
	//--------------------------------------
	case 0x70://操作场景(恢复场景)
		memcpy(pCmdBuf, cmd77, sizeof(cmd77));

		tempGroupAddr = ((UINT16)0x01) << gUpMsgBuffer.upDataBlock[2];
		Big_uint16ToStr(&pCmdBuf[7], tempGroupAddr);//组地址
		Big_uint16ToStr(&pCmdBuf[11], tempGroupAddr);//组ID
		pCmdBuf[13] = gUpMsgBuffer.upDataBlock[3];//场景ID

		SendUartCommand(pCmdBuf, sizeof(cmd77));

		gRespUpBuffer.wifiProcotolParm = gUpMsgBuffer.wifiProcotolParm;//保存wifi协议数据，不被清除
		memcpy(gRespUpBuffer.upDataBlock, gUpMsgBuffer.upDataBlock, gUpMsgBuffer.wifiProcotolParm.dataLen);//保存协议数据中的数据块
		gUpMsgBuffer.upMsgBufferState = BufferEmpty;//标记缓存为空
		gZigBeeObject.ctrlSequence = 0x71;
	break;
	case 0x71://等待协调器响应(只适用运行新节点加入命令后的等待操作)
		if( (0x00 == gZigBeeObject.cmdAckFlag) && ((tempTime - gZigBeeObject.receUartTime) > 10) ){
			gZigBeeObject.ctrlSequence = 0xE2;//操作成功
		}else if( (tempTime - gZigBeeObject.sendCmdTime) > 500 ){ //500ms超时
			errSource = 0x01;//协调器没响应
			gZigBeeObject.ctrlSequence = 0x72;	//操作失败
		}
	break;
	case 0x72://处理出错跳转到此状态
		gZigBeeObject.ctrlSequence = 0xE2;
	break;
	//--------------------------------------
	case 0x80://绑定
		if( 0x01 == gUpMsgBuffer.upDataBlock[15] )
		{
			memcpy(pCmdBuf, cmd78_GroupAddr, sizeof(cmd78_GroupAddr));

			tempGroupAddr = ((UINT16)0x01) << gUpMsgBuffer.upDataBlock[16];
			memcpy(&pCmdBuf[6], gUpMsgBuffer.upDataBlock[2], 8);
			pCmdBuf[14] = 0x01;
			Big_uint16ToStr(&pCmdBuf[18], tempGroupAddr);//组地址
			SendUartCommand(pCmdBuf, sizeof(cmd78_GroupAddr));
		}else if( 0x03 == gUpMsgBuffer.upDataBlock[2] )
		{
			/* 匹配地址 */
			tempNodeNum = SearchNode(&gUpMsgBuffer.upDataBlock[2]);
			if( NODE_NUM_MAX <= tempNodeNum )
			{
				errSource = 0x12;//没有匹配的地址
				gZigBeeObject.ctrlSequence = 0x42;	
				break;
			}
			
			memcpy(pCmdBuf, cmd78_IeeeAddr, sizeof(cmd78_IeeeAddr));

			tempGroupAddr = ((UINT16)0x01) << gUpMsgBuffer.upDataBlock[16];
			memcpy(&pCmdBuf[6], gUpMsgBuffer.upDataBlock[2], 8);
			pCmdBuf[14] = 0x01;
			memcpy(&pCmdBuf[18], gUpMsgBuffer.upDataBlock[16], 8);
			pCmdBuf[26] = gZigBeeObject.gNodeInfo[tempNodeNum].endPoint;
			SendUartCommand(pCmdBuf, sizeof(cmd78_IeeeAddr));
		}
		gRespUpBuffer.wifiProcotolParm = gUpMsgBuffer.wifiProcotolParm;//保存wifi协议数据，不被清除
		memcpy(gRespUpBuffer.upDataBlock, gUpMsgBuffer.upDataBlock, gUpMsgBuffer.wifiProcotolParm.dataLen);//保存协议数据中的数据块
		gUpMsgBuffer.upMsgBufferState = BufferEmpty;//标记缓存为空
		gZigBeeObject.ctrlSequence = 0x81;
	break;
	case 0x81://等待遥控器的绑定响应消息
		if((gZigBeeObject.nodeMsgRespType & ((UINT16)Resp_BIND_TYPE)) && ((tempTime - gZigBeeObject.receUartTime) > 10)){//接收到了控制节点OK的消息，并且应答后延时10ms	
			gZigBeeObject.ctrlSequence = 0xE3;
		}else if((tempTime - gZigBeeObject.sendCmdTime) > 1000){ //1000ms超时
			if(gZigBeeObject.cmdAckFlag == 0x00){
				errSource = 0x02;//节点没响应
			}else if(gZigBeeObject.cmdAckFlag == 0xFF){
				errSource = 0x01;//协调器没响应
			}
			gZigBeeObject.ctrlSequence = 0x82;
		}
	break;
	case 0x82://处理出错跳转到此状态
		gZigBeeObject.ctrlSequence = 0xE3;
	break;

	//---------------------------------------------------------------------	
	case 0xE0://控制类 反馈给上层的消息状态
		/* 是组控还是单控 */
		if(UP_CMD_SHORT_CTRL == gRespUpBuffer.wifiProcotolParm.cmd)
		{//单控的反馈
			memcpy(ackBuf, gRespUpBuffer.upDataBlock, gRespUpBuffer.wifiProcotolParm.dataLen);
		}else{//组控的反馈
			memcpy(ackBuf, gRespUpBuffer.upDataBlock, gRespUpBuffer.wifiProcotolParm.dataLen);
		}
		ackBuf[gRespUpBuffer.wifiProcotolParm.dataLen] = ackBuf[gRespUpBuffer.wifiProcotolParm.dataLen -1];
		ackBuf[gRespUpBuffer.wifiProcotolParm.dataLen -1] = errSource;
		ackLen = gRespUpBuffer.wifiProcotolParm.dataLen + 1;
	
		UdpManage_sendData(ackBuf, ackLen, 0, &(gRespUpBuffer.wifiProcotolParm));
		gZigBeeObject.ctrlSequence = 0xF0;
	break;
	case 0xE1://允许节点加入 反馈给上层的消息状态
		ackBuf[0] = errSource;
		ackLen = 1;
		
		UdpManage_sendData(ackBuf, ackLen, 0, &(gRespUpBuffer.wifiProcotolParm));
		gZigBeeObject.ctrlSequence = 0xF0;
	break;
	case 0xE2://场景相关 反馈给上层的消息状态
		ackBuf[0] = errSource;
		ackBuf[1] = gRespUpBuffer.upDataBlock[2];
		ackBuf[2] = gRespUpBuffer.upDataBlock[3];
		ackLen = 3;
	
		UdpManage_sendData(ackBuf, ackLen, 0, &(gRespUpBuffer.wifiProcotolParm));
		gZigBeeObject.ctrlSequence = 0xF0;
	break;
	case 0xE3://绑定相关 反馈给上层的消息状态
		memcpy(ackBuf, gRespUpBuffer.upDataBlock, 13);
		ackBuf[13] = errSource;
		ackLen = 14;
	
		UdpManage_sendData(ackBuf, ackLen, 0, &(gRespUpBuffer.wifiProcotolParm));
		gZigBeeObject.ctrlSequence = 0xF0;
	break;
	//---------------------------------
	case 0xF0:
		ZIGBEE_ASW_PRINTF("CtrlNodeS: errFlag: %x.\n", errSource); 
		gUpMsgBuffer.upMsgBufferState = BufferEmpty;//标记缓存为空 .冗余操作
		gZigBeeObject.ableCtrlFlag = AllowCtrl;//允许上层发送控制命令标记
		outFlag = SUB_STATE_END;
	break;
	default:
		gZigBeeObject.ctrlSequence = 0x00;
	break;
	}

	return(outFlag);
}

/**************************************************************
* 名称 : AddShortAddr
* 功能 : 添加节点的短地址和通信端口.
*
* 参数 : pShortAddr : in :  要保存的节点短地址
*	    pEndPoint  : in :  要保存的节点的通信端口
* 返回 : flag   : 节点标志; 0:新节点; 1:旧节点; 2:存储满; 0xFF:出错;
*
* 备注 : 1.获取已在网络中的节点短地址和端口号时，
*		  接收MATCH_DESCRIPTOR_REQUEST消息时使用该函数.
**************************************************************/
UINT8  AddShortAddr(UINT8 *pShortAddr,UINT8 *pEndPoint)
{
	UINT8    flag,i;
	UINT16  tempShortAddr;
	
	flag = 0xFF;//默认出错
	if( (pShortAddr == NULL) || (pEndPoint == NULL) )
	{
		goto goto_AddShortAddr;
	}

	tempShortAddr = Big_str2uint16(pShortAddr);

	for(i = 0; i < NODE_NUM_MAX; i++)
	{
		/* 以前已经添加了此节点 */
		if(tempShortAddr == gZigBeeObject.gNodeInfo[i].shortAddr )
		{
			ZIGBEE_ASW_PRINTF("AddShortAddr: old have.\n");

			/* 判别是旧节点,也重新覆盖该节点的端口号数据,保证保存的数据正确,是一种纠错行为 */
			gZigBeeObject.gNodeInfo[i].endPoint = pEndPoint[0];
			gZigBeeObject.gNodeInfo[i].nodeIndicate |= (UINT8)NODE_OBTAIN_END_POINT_FLAG;//把该节点的节点指示标记为已查询通信端口号
			
			flag = 1;//0:新节点; 1:旧节点; 2:存储满; 0xFF:出错;
			break;
		}

		/* 节点是否为空 */
		if( 0 == gZigBeeObject.gNodeInfo[i].shortAddr )
		{
			gZigBeeObject.gNodeInfo[i].shortAddr = tempShortAddr;
			gZigBeeObject.gNodeInfo[i].endPoint = pEndPoint[0];
			
			gZigBeeObject.gNodeInfo[i].nodeIndicate |= (UINT8)NODE_OBTAIN_END_POINT_FLAG;//把该节点的节点指示标记为已查询通信端口号

			ZIGBEE_ASW_PRINTF("AddShortAddr: index:%d. addr:", i);
			ZIGBEE_ASW_OUTSTR(pShortAddr, 2);
			ZIGBEE_ASW_PRINTF(".\n");
			
			flag = 0;//0:新节点; 1:旧节点; 2:存储满; 0xFF:出错;
			break;
		}
	}

	if( NODE_NUM_MAX == i )//节点存储已满
	{
		flag = 2;//0:新节点; 1:旧节点; 2:存储满; 0xFF:出错;
		ZIGBEE_ASW_PRINTF("AddShortAddr: Node is full !.\n");
	}

goto_AddShortAddr:
	return(flag);
}

/**************************************************************
* 名称 : AddNewNodeAddr
* 功能 : 添加新节点地址,包括短地址和Ieee地址.
*
* 参数 : pShortAddr : in :  要保存的节点短地址
*	      pIeeeAddr  : in :  要保存的节点Ieee地址
* 返回 : flag   : 节点标志; 0:新节点; 1:旧节点; 2:存储满; 0xFF:出错;
*
* 备注 : 1. 新节点加入网络时，在接收新节点的Announce消息时使用该函数
*	      2. 接收Announce消息的时候，里面包含了节点的Ieee地址和短地址
**************************************************************/
UINT8  AddNewNodeAddr(UINT8 *pShortAddr, UINT8 *pIeeeAddr)
{
	UINT8	 flag,i;
	UINT16     tempShortAddr;
	
	flag = 0xFF;//默认出错
	if( (pShortAddr == NULL) || (pIeeeAddr == NULL) )
	{
		goto goto_AddNewNodeAddr;
	}

	tempShortAddr = Big_str2uint16(pShortAddr);
	for(i = 0; i < NODE_NUM_MAX; i++)
	{
		if( tempShortAddr == gZigBeeObject.gNodeInfo[i].shortAddr )//以前已经添加了此节点
		{
			ZIGBEE_ASW_PRINTF("AddNewNodeAddr: old have.\n");
			flag = 1; //0:新节点; 1:旧节点; 2:存储满; 0xFF:出错;
			break;
		}
		
		if( 0 == gZigBeeObject.gNodeInfo[i].shortAddr )//节点是否为空
		{
			gZigBeeObject.gNodeInfo[i].shortAddr = tempShortAddr;
			memcpy(gZigBeeObject.gNodeInfo[i].IeeeAddr,pIeeeAddr,8);

			gZigBeeObject.gNodeInfo[i].nodeIndicate |= (UINT8)NODE_OBTAIN_IEEE_ADDR_FLAG;//把该节点的节点指示标记为已查询Ieee地址

			ZIGBEE_ASW_PRINTF("AddNewNodeAddr: index:%d. addr:", i);
			ZIGBEE_ASW_OUTSTR(pShortAddr, 2);
			ZIGBEE_ASW_PRINTF(".\n");

			flag = 0; //0:新节点; 1:旧节点; 2:存储满; 0xFF:出错;
			break;
		}
	}

	if(NODE_NUM_MAX == i)
	{
		flag = 2;//0:新节点; 1:旧节点; 2:存储满; 0xFF:出错;
		ZIGBEE_ASW_PRINTF("AddNewNodeAddr: Node is full !.\n");
	}

goto_AddNewNodeAddr:
	return(flag);
}

/**************************************************************
* 名称 : AddIeeeAddr
* 功能 : 添加节点的Ieee地址.
*
* 参数 : iShortAddr : in :  待查询节点的节点短地址;
*	    pIeeeAddr  : in :  要保存的节点的Ieee地址
* 返回 : err   : 出错标志; 0:OK; 1:参数错误;
*
* 备注 : 1. 01 80 41 00 0E D9 C3 00 [00 15 8D 00 00 36 02 D4] [A3 0E] 00 00 03
**************************************************************/
UINT8  AddIeeeAddr(UINT16 iShortAddr, UINT8 *pIeeeAddr)
{
	UINT8 err,i,tempNodeNum;

	err = 1;//参数错误,添加失败
	if(pIeeeAddr == NULL){ goto goto_AddIeeeAddr; }

	tempNodeNum = GetNodeNum();//获取节点个数
	for(i=0;i<tempNodeNum;i++)
	{
		if( iShortAddr == gZigBeeObject.gNodeInfo[i].shortAddr )
		{
			memcpy(gZigBeeObject.gNodeInfo[i].IeeeAddr,  pIeeeAddr, 8);
			gZigBeeObject.gNodeInfo[i].nodeIndicate |= (UINT8)NODE_OBTAIN_IEEE_ADDR_FLAG;//把该节点的节点指示标记为已查询Ieee地址
			err = 0;//OK
			
			ZIGBEE_ASW_PRINTF("AddIeeeAddr: index:%d. addr:", i);
			ZIGBEE_ASW_OUTSTR(pIeeeAddr, 8);
			ZIGBEE_ASW_PRINTF(".\n");
			
			break;
		}
	}

goto_AddIeeeAddr:
	return(err);
}

/**************************************************************
* 名称 : AddNodeEndPoint
* 功能 : 添加新节点的通信端口号.
*
* 参数 : iShortAddr : in :  待查询节点的节点短地址;
*	    pEndPoint  : in :  要保存的新节点的通信端口号;	    
* 返回 : err   : 出错标志; 0:OK; 1:参数错误;
*
* 备注 : 1. 有新节点加入时才使用该函数
**************************************************************/
UINT8 AddNodeEndPoint(UINT16 iShortAddr, UINT8 *pEndPoint)
{
	UINT8 err,i,tempNodeNum;

	err = 1;//参数错误,添加失败
	if(pEndPoint == NULL){ goto goto_AddNodeEndPoint; }
	
	tempNodeNum = GetNodeNum();//获取节点个数
	for(i = 0;i < tempNodeNum;i++)
	{
		if( iShortAddr == gZigBeeObject.gNodeInfo[i].shortAddr )
		{
			gZigBeeObject.gNodeInfo[i].endPoint = pEndPoint[0];
			gZigBeeObject.gNodeInfo[i].nodeIndicate |= (UINT8)NODE_OBTAIN_END_POINT_FLAG;//把该节点的节点指示标记为已查询节点通信端口号
			err = 0;//OK

			break;
		}
	}

goto_AddNodeEndPoint:
	return(err);
}

/**************************************************************
* 名称 : AddDeviceType
* 功能 : 添加节点的设备类型.
*
* 参数 : iShortAddr  : in :  待查询节点的节点短地址;
*	    pDeviceType : in :  要保存的节点的设备类型值;	    
* 返回 : err   : 出错标志; 0:OK; 1:参数错误;
*
* 备注 : 1. 
**************************************************************/
UINT8  AddDeviceType(UINT16 iShortAddr,UINT8 *pDeviceType)
{
	UINT8   err, i, tempNodeNum;

	err = 1;//参数错误,添加失败
	if(pDeviceType == NULL){ goto goto_AddDeviceType; }

	tempNodeNum = GetNodeNum();//获取节点个数
	for(i = 0;i < tempNodeNum;i++)
	{
		if( iShortAddr == gZigBeeObject.gNodeInfo[i].shortAddr )
		{
			gZigBeeObject.gNodeInfo[i].deviceType = Big_str2uint16(pDeviceType);
			gZigBeeObject.gNodeInfo[i].nodeIndicate |= (UINT8)NODE_OBTAIN_DEV_TYPE_FLAG;//把该节点的节点指示标记为已查询设备类型
			err = 0;//OK
			
			break;
		}
	}

goto_AddDeviceType:
	return(err);
}

/**************************************************************
* 名称 : AddCurrentStateValue
* 功能 : 添加节点的当前状态值.
*
* 参数 : iShortAddr : in :  待查询节点的节点短地址;
*       pClusterID  : in :  查询的属性值所属的Cluster ID;
*	   pStateValue : in :  要保存的节点的当前状态值;
* 返回 : err   : 出错标志; 0:OK; 1:参数错误;
*
* 备注 : 1. 
**************************************************************/
UINT8 AddCurrentStateValue(UINT16 iShortAddr, UINT8 *pClusterID, UINT8 *pStateValue)
{
	UINT8 	err, i, tempNodeNum;
	UINT16    tempClusterID,tempColorTempValue;

	err = 1;//参数错误,添加失败
	if( (pClusterID == NULL) || (pStateValue == NULL) )
	{
		goto goto_AddCurrentStateValue;
	}
	
	tempNodeNum = GetNodeNum();//获取节点个数
	for(i = 0;i < tempNodeNum;i++)
	{
		if( iShortAddr == gZigBeeObject.gNodeInfo[i].shortAddr )
		{
			gZigBeeObject.gNodeInfo[i].nodeIndicate |= (UINT8)NODE_OBTAIN_ONLINE_FLAG;//查询完状态便默认该节点在线

			switch(gZigBeeObject.gNodeInfo[i].deviceType)
			{
			case LIGHT_ONOFF_CTRL:
				if(0x01 == pStateValue[0]){
					gZigBeeObject.gNodeInfo[i].currentState.onOffNode.onOffValue = 0x55;//开
				}else if(0x00 == pStateValue[0]){
					gZigBeeObject.gNodeInfo[i].currentState.onOffNode.onOffValue = 0xAA;//关
				}else{
					//无
				}
			break;
			case LIGHT_LEVEL_CTRL:
				tempClusterID = Big_str2uint16(pClusterID);//获取当前的状态值所属的Cluster ID

				if( CLUSTER_ID_LEVEL_CTRL == tempClusterID )
				{
					if( 0xFE == pStateValue[0] ){
						gZigBeeObject.gNodeInfo[i].currentState.levelNode.levelValue = 0xFF;//把亮度等级的最大值设为0xFF;按照协议来
					}else{
						gZigBeeObject.gNodeInfo[i].currentState.levelNode.levelValue = pStateValue[0];
					}
				}else if( CLUSTER_ID_ONOFF_CTRL == tempClusterID ){
					if( 0x00 == pStateValue[0] ){//当节点开关状态为关,就把亮度等级赋值为0
						gZigBeeObject.gNodeInfo[i].currentState.levelNode.levelValue = pStateValue[0];
					}else{
						//当节点开关状态为开,就不做处理
					}
				}
			break;
			case LIGHT_COLOUR_CTRL:
				tempClusterID = Big_str2uint16(pClusterID);//获取当前的状态值所属的Cluster ID

				if(CLUSTER_ID_COLOUR_CTRL == tempClusterID){
					tempColorTempValue = Big_str2uint16(pStateValue);
						
					if( ((UINT16)0x9A) >= tempColorTempValue ){
						gZigBeeObject.gNodeInfo[i].currentState.colourTempNode.colourTempValue = 0x00;//0x00 = 0,0x9A = 154,色温值以154为基准
					}else if( 0x0172 <= tempColorTempValue ){
						gZigBeeObject.gNodeInfo[i].currentState.colourTempNode.colourTempValue = 0xD8;//0xD8 = 216,协议色温值:0 - 216 , 实际色温程序设置值:154 - 370
					}else{
						gZigBeeObject.gNodeInfo[i].currentState.colourTempNode.colourTempValue = tempColorTempValue -((UINT16)0x9A);
					}
				}else if(CLUSTER_ID_LEVEL_CTRL == tempClusterID){
					if( 0xFE == pStateValue[0] ){
						gZigBeeObject.gNodeInfo[i].currentState.colourTempNode.levelValue = 0xFF;//把亮度等级的最大值设为0xFF;按照协议来
					}else{
						gZigBeeObject.gNodeInfo[i].currentState.colourTempNode.levelValue = pStateValue[0];
					}
				}else if(CLUSTER_ID_ONOFF_CTRL == tempClusterID){
					if( 0x00 == pStateValue[0] ){//当节点开关状态为关,就把亮度等级赋值为0
						gZigBeeObject.gNodeInfo[i].currentState.levelNode.levelValue = pStateValue[0];
					}else{
						//当节点开关状态为开,就不做处理
					}
				}
			break;
			default:
			break;
			}

			err = 0;//OK
			goto goto_AddCurrentStateValue;
		}
	}
	
goto_AddCurrentStateValue:
	return(err);
}

/**************************************************************
* 名称 : AddGroupAddr
* 功能 : 添加节点所在组的组地址.
*
* 参数 : iShortAddr    : in :  待查询节点的节点短地址;
*	    iGroupCapacity: in :  节点剩下的组容量;
*	    iGroupCount   : in :  节点所在组的组数;	  
*	    pGroupAddr	   : in :  组地址列表首地址;
* 返回 : err   : 出错标志; 0:OK; 1:参数错误;
*
* 备注 : 1. pGroupAddr -- 组地址是16位的数据,每一位标记为一个组
**************************************************************/
UINT8  AddGroupAddr(UINT16 iShortAddr, UINT8 iGroupCapacity, UINT8 iGroupCount, UINT8 *pGroupAddr)
{
	UINT8   err, i, j, tempNodeNum;
	UINT16 tempGroupAddr;

	err = 1;//参数错误,添加失败
	if(pGroupAddr == NULL){ goto goto_AddGroupAddr; }

	ZIGBEE_ASW_PRINTF("AddGroupAddr: iShortAddr:%x,Capacity:%x.\n", iShortAddr, iGroupCapacity);
	tempNodeNum = GetNodeNum();//获取节点个数
	for(i = 0;i < tempNodeNum;i++)
	{
		if( iShortAddr == gZigBeeObject.gNodeInfo[i].shortAddr )
		{	
			/* 判别节点剩下的组容量 */
			if(0x00 == iGroupCapacity){//节点剩下的组容量为0,表明节点储存的组地址已满
				gZigBeeObject.gNodeInfo[i].nodeIndicate |= (UINT8)NODE_GROUP_STORE_FULL_FLAG;
			}else{//节点剩下的组容量不为0,表明未满
				gZigBeeObject.gNodeInfo[i].nodeIndicate &= (~(UINT8)NODE_GROUP_STORE_FULL_FLAG);
			}

			gZigBeeObject.gNodeInfo[i].nodeGroupAddr = 0x0000;//每次获取组信息,都先清除原始数据,因为下面的处理是或等于

			/* 把节点的组地址信息按位与到一起存储 */
			for(j = 0;j < iGroupCount;j++)
			{
				tempGroupAddr = Big_str2uint16(&pGroupAddr[j*2]);//取出组地址
				ZIGBEE_ASW_PRINTF("-------pGroupAddr:%x.\n", tempGroupAddr);
				
				if( 0 == CheckGroupAddr(tempGroupAddr) )
				{//有效组地址则保存
					gZigBeeObject.gNodeInfo[i].nodeGroupAddr |= tempGroupAddr;
				}else{//无效组地址需删除
					gNodeInvalidGroup[0] = iShortAddr;//无效组地址的节点短地址.
					gNodeInvalidGroup[1] = tempGroupAddr;//无效组地址.
				}
			}

			/* 系统初始化时获取的组信息赋值到upGroup(虚的)中,之后获取的组信息不赋值到upGroup中 */
			if( 0x00 == (gZigBeeObject.gNodeInfo[i].nodeIndicate & (UINT8)NODE_INIT_OBTAIN_GROUP_FLAG) ){
				gZigBeeObject.gNodeInfo[i].upGroupAddr = gZigBeeObject.gNodeInfo[i].nodeGroupAddr;
				gZigBeeObject.gNodeInfo[i].nodeIndicate |= (UINT8)NODE_INIT_OBTAIN_GROUP_FLAG;//标记该节点已初始化获取组地址
			}else{
				gZigBeeObject.gNodeInfo[i].nodeIndicate |= (UINT8)NODE_INIT_OBTAIN_GROUP_FLAG;//冗余操作,确保初始化后节点获取组信息的标记始终是正确的
			}

			err = 0;//OK
			break;
		}
	}

goto_AddGroupAddr:
	return(err);
}

/**************************************************************
* 名称 : GetAttrQueryNumber
* 功能 : 获得节点属性不完整的查询编号.
*
* 参数 : iQueryNumber : in :  查询起始编号;
* 返回 : tempNodeNum  : 查询到的编号; <NODE_NUM_MAX: 正确的编号; NODE_NUM_MAX:查询完毕(参数错误);
*
* 备注 : 1.
**************************************************************/
UINT8  GetAttrQueryNumber(UINT8 iQueryNumber)
{
	UINT8  queryNodeNum, tempNodeNum, i;
	
	queryNodeNum = NODE_NUM_MAX;//默认 参数错误 //默认查询完毕
	if(iQueryNumber >= NODE_NUM_MAX)
	{
		goto goto_GetAttrQueryNumber;
	}
	
	tempNodeNum = GetNodeNum();//获取节点个数
	for(i = iQueryNumber; i < tempNodeNum; i++)
	{
		if( ((UINT8)NODE_OBTAIN_ATTR_COMPLETE) != ((gZigBeeObject.gNodeInfo[i].nodeIndicate) & ((UINT8)NODE_OBTAIN_ATTR_COMPLETE)) ){//如果节点的属性标记位都为1则表示信息完整
			queryNodeNum = i;
			goto goto_GetAttrQueryNumber;//有节点的属性不完整
		}
	}

goto_GetAttrQueryNumber:
	return(queryNodeNum);
}

/**************************************************************
* 名称 : GetGroupQueryNumber
* 功能 : 获得节点组地址的查询编号.
*
* 参数 : iQueryNumber : in :  查询起始编号;
* 返回 : tempNodeNum  : 查询到的编号; <NODE_NUM_MAX: 正确的编号; NODE_NUM_MAX:查询完毕(参数错误);
*
* 备注 : 1.查询节点的组地址,需指定端口号,所以该节点必须先查询了节点的端口号
**************************************************************/
UINT8  GetGroupQueryNumber(UINT8 iQueryNumber)
{
	UINT8  queryNodeNum, tempNodeNum, i;
	
	queryNodeNum = NODE_NUM_MAX;//默认 参数错误 //默认查询完毕
	if(iQueryNumber >= NODE_NUM_MAX)
	{
		goto goto_GetGroupQueryNumber;
	}
	
	tempNodeNum = GetNodeNum();//获取节点的个数
	for(i = iQueryNumber; i < tempNodeNum; i++)
	{
		if( (((UINT8)NODE_OBTAIN_END_POINT_FLAG) == ((gZigBeeObject.gNodeInfo[i].nodeIndicate) & ((UINT8)NODE_OBTAIN_END_POINT_FLAG))) && 
		      (((UINT8)NODE_OBTAIN_GROUP_ADDR_FLAG) != ((gZigBeeObject.gNodeInfo[i].nodeIndicate) & ((UINT8)NODE_OBTAIN_GROUP_ADDR_FLAG))) )
		{//如果节点的端口号标记位标记为 已查询, 以及节点的组地址标记位 没有 标记,才能去查询组地址
			queryNodeNum = i;
			goto goto_GetGroupQueryNumber;
		}
	}

goto_GetGroupQueryNumber:
	return(queryNodeNum);
}

/**************************************************************
* 名称 : GetStateQueryNumber
* 功能 : 获得节点状态查询编号
*
* 参数 : iQueryNumber: in :  节点起始查询编号；
* 返回 : tempNodeNum   : 查询到的编号; <NODE_NUM_MAX: 正确的编号; NODE_NUM_MAX:查询完毕(参数错误);
*
* 备注 : 1.
**************************************************************/
UINT8  GetStateQueryNumber(UINT8 iQueryNumber)
{
	UINT8  queryNodeNum, tempNodeNum, i;

	queryNodeNum = NODE_NUM_MAX;//默认查询完毕和,参数错误
	if(iQueryNumber >= NODE_NUM_MAX)
	{
		goto goto_GetStateQueryNumber;
	}

	tempNodeNum = GetNodeNum();//获取节点个数
	for(i = iQueryNumber; i < tempNodeNum; i++)
	{
		if( ((UINT8)NODE_OBTAIN_ATTR_COMPLETE) == ((gZigBeeObject.gNodeInfo[i].nodeIndicate) & ((UINT8)NODE_OBTAIN_ATTR_COMPLETE)) )//节点属性完整,才查询节点状态值
		{
			queryNodeNum = i;
			goto goto_GetStateQueryNumber;
		}
	}

goto_GetStateQueryNumber:
	return(queryNodeNum);
}

/**************************************************************
* 名称 : GetNodeNum
* 功能 : 获得节点数目.
*
* 参数 : pNodeAddr : in :  要转换的字符串指针;
* 返回 : 节点数目;
*
* 备注 : 1.
**************************************************************/
//const UINT8  NULL_IEEE_ADDR[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
UINT8  GetNodeNum(void)
{
	UINT8    i;

	for(i = 0; i < NODE_NUM_MAX; i++)
	{
		if( 0 == gZigBeeObject.gNodeInfo[i].shortAddr )//节点是否为空
		{
			break;
		}
	}
	
	return(i);
}

/**************************************************************
* 名称 : vSaveControllerInfo
* 功能 : 保存遥控器的信息.
*
* 参数 : pControllerInfo : in :  要转换的字符串指针;
* 返回 : 
*
* 备注 : 1.
**************************************************************/
void  vSaveControllerInfo(UINT8 *pControllerInfo)
{
	UINT8	i;
	gControllerInfo.controllerType = (UINT16)pControllerInfo[8];//保存遥控器的类型
	memcpy(gControllerInfo.IeeeAddr,pControllerInfo,8);//保存遥控器IEEE地址
	gControllerInfo.validFlag = 0x00;//没有遥控器数据，数据无效。冗余操作，保证在数据有效前都是无效数据
	
	for(i=0;i<8;i++)
	{
		if( 0 != pControllerInfo[i])
		{
			gControllerInfo.validFlag = 0x55;//数据有效
			break;
		}
	}
}

/**************************************************************
* 名称 : AddNodeToGroup
* 功能 : 添加节点到组里.
*
* 参数 : pIeeeAddr : in :  要添加的节点的Ieee地址;
* 		iAddNum  : in :  添加的节点数量;
*	   iGroupNum  : in :  组编号;
* 返回 : num ; 操作成功的数目
*
* 备注 : 1.
**************************************************************/
UINT8  AddNodeToGroup(UINT8 *pIeeeAddr, UINT8 iAddNum, UINT8 iGroupNum)
{
	UINT8 i, tempNodeNum, num = 0;
	
	if( (pIeeeAddr == NULL) ||(iAddNum >= NODE_NUM_MAX) ||(iGroupNum >= 16) )
	{
		num = NODE_NUM_MAX;//参数错误
		goto goto_AddNodeToGroup;
	}

	for(i=0;i<iAddNum;i++)
	{
		tempNodeNum = SearchNode(&pIeeeAddr[i*8]);
		if( NODE_NUM_MAX <= tempNodeNum )
		{
			continue;//没有匹配的节点,添加下一个节点
		}else{
			num = num + 1;
		}

		gZigBeeObject.gNodeInfo[tempNodeNum].upGroupAddr |= ( (UINT16)0x01 ) << iGroupNum;
		gZigBeeObject.gNodeInfo[tempNodeNum].nodeIndicate &= (~(UINT8)NODE_OBTAIN_GROUP_ADDR_FLAG);//该节点有组的操作,所以要标记该节点没有查询组
	}

goto_AddNodeToGroup:
	return(num);
}

/**************************************************************
* 名称 : GetNodeNum
* 功能 : 删除组里的节点.
*
* 参数 : pIeeeAddr : in :  要删除的节点的Ieee地址;
* 		iAddNum  : in :  删除的节点数量;
*	   iGroupNum  : in :  组编号;
* 返回 : num ; 操作成功的数目
*
* 备注 : 1.
**************************************************************/
UINT8  DelNodeFromGroup(UINT8 *pIeeeAddr, UINT8 iAddNum, UINT8 iGroupNum)
{
	UINT8 i, tempNodeNum, num = 0;
	uint16 tempDelGroupAddr;
	
	if( (pIeeeAddr == NULL) ||(iAddNum >= NODE_NUM_MAX) ||(iGroupNum >= 16) )
	{
		num = NODE_NUM_MAX;//参数错误
		goto goto_DelNodeFromGroup;
	}

	tempDelGroupAddr = ( (UINT16)0x01 ) << iGroupNum;
	for(i=0;i<iAddNum;i++)
	{
		tempNodeNum = SearchNode(&pIeeeAddr[i*8]);
		if( NODE_NUM_MAX <= tempNodeNum )
		{
			continue;//没有匹配的节点,删除下一个节点
		}else{
			num = num + 1;
		}

		gZigBeeObject.gNodeInfo[tempNodeNum].upGroupAddr &= (~tempDelGroupAddr);
		gZigBeeObject.gNodeInfo[tempNodeNum].nodeIndicate &= (~(UINT8)NODE_OBTAIN_GROUP_ADDR_FLAG);//该节点有组的操作,所以要标记该节点没有查询组
	}
	
goto_DelNodeFromGroup:
	return(num);
}


/**************************************************************
* 名称 : SearchNode
* 功能 : 通过上层发送的节点Ieee地址匹配短地址和提取节点编号.
*
* 参数 : pIeeeAddr : in :  要比较的 Ieee地址;
*
* 返回 : num   : 匹配的结果; < NODE_NUM_MAX:有匹配的地址; NODE_NUM_MAX:没有匹配的地址
*
* 备注 : 1.
**************************************************************/
UINT8  SearchNode(UINT8 *pIeeeAddr)
{
	UINT8	num, i ,tempNodeNum;
	UINT8    *pNodeAddr;
	
	num = NODE_NUM_MAX;//参数错误 //默认没有匹配
	if( pIeeeAddr == NULL )
	{
		goto goto_SearchNode;
	}

	tempNodeNum = GetNodeNum();//获取节点个数
	for(i = 0; i < tempNodeNum; i++)
	{
		pNodeAddr = gZigBeeObject.gNodeInfo[i].IeeeAddr;
		
		if(memcmp(pIeeeAddr, pNodeAddr, 8) == 0)
		{
			num = i;//通过MAC地址获取的节点编号
			goto goto_SearchNode;//跳出循环
		}
	}

goto_SearchNode:
	return(num);
}

/**************************************************************
* 名称 : QuerySlaveAllMac
* 功能 : 查询ZigBee的所有节点地址信息。
*
* 参数 : pAckData     : out : 打包好的协议数据块数据;
*        StartMAC     :  in : 查询节点的MAC地址开始的序号;
*        iNum         :  in : 查询节点设备MAC地址的个数;
* 返回 : len          :  打包后,协议的长度; 0:err;
*
* 备注 : 1.
**************************************************************/
UINT16  QuerySlaveAllMac(UINT8 *pAckData, UINT8 StartMAC, UINT8 iNum)
{
	UINT8     allNum, i;
	UINT16    len = 0;

	if(pAckData == NULL) {
		return(0);
	}
	
	allNum = GetNodeNum();//全部节点数(带有Ieee地址信息的节点)
	if(allNum <= StartMAC)
	{
		iNum = 0;
	} else {
		if((allNum - StartMAC) < iNum)
		{
			iNum = allNum - StartMAC;
		}
	}

	pAckData[0] = allNum;//主控设备保存MAC地址的个数,最大值为255.
	pAckData[1] = StartMAC;//MAC地址开始的序号
	pAckData[2] = iNum;//传输的MAC地址个数

	len = 3 + 15*iNum;
	
	ZIGBEE_ASW_PRINTF("QSAM:Total:%d.StartNum:%d.OutNum:%d.\n",allNum, StartMAC, iNum);

	if(iNum != 0)
	{
		for(i = StartMAC; i < (StartMAC+iNum); i++)
		{
			memcpy(&pAckData[3+(i-StartMAC)*15+0], &(gZigBeeObject.gNodeInfo[i].IeeeAddr[0]), 8);//MAC地址(8个字节)
			Little_uint16ToStr(&pAckData[3+(i-StartMAC)*15+8], gZigBeeObject.gNodeInfo[i].deviceType);//节点的设备类型(2个字节)
			Little_uint16ToStr(&pAckData[3+(i-StartMAC)*15+10], gZigBeeObject.gNodeInfo[i].nodeGroupAddr);//节点的组信息(2个字节)

			ZIGBEE_ASW_PRINTF("QSAM:Node[%d]=%x.", i, gZigBeeObject.gNodeInfo[i].nodeIndicate);
			pAckData[3+(i-StartMAC)*15+12] = 0;//初始化为0
			/* 判断节点是否在线 */
			if( 0x0F == ((gZigBeeObject.gNodeInfo[i].nodeIndicate) & 0x0F) ){
				ZIGBEE_ASW_PRINTF("on-line.");
				pAckData[3+(i-StartMAC)*15+12] |= 0x01;//该节点有Ieee地址、通信端口号、设备类型信息,并且在线,才标记为节点在线(bit0)
			}else{
				ZIGBEE_ASW_PRINTF("off-line.");
			}
			/* 判断节点储存的组地址是否已满 */
			if( NODE_GROUP_STORE_FULL_FLAG == ((gZigBeeObject.gNodeInfo[i].nodeIndicate) & NODE_GROUP_STORE_FULL_FLAG)){
				ZIGBEE_ASW_PRINTF("-Group full.\n");
				pAckData[3+(i-StartMAC)*15+12] |= 0x02;//该节点储存的组已满(bit1)
			}else{
				ZIGBEE_ASW_PRINTF("-Group no full.\n");
			}

			switch(gZigBeeObject.gNodeInfo[i].deviceType)
			{
				case LIGHT_ONOFF_CTRL:
					pAckData[3+(i-StartMAC)*15+13] = 0x00;//填充字节

					if( 0x01 == gZigBeeObject.gNodeInfo[i].currentState.onOffNode.onOffValue ){
						pAckData[3+(i-StartMAC)*15+14] = 0x55;//当前状态为开
					}else{
						pAckData[3+(i-StartMAC)*15+14] = 0xAA;//当前状态为关
					}
				break;
				case LIGHT_LEVEL_CTRL:
					pAckData[3+(i-StartMAC)*15+13] = 0x00;//填充字节
					pAckData[3+(i-StartMAC)*15+14] = gZigBeeObject.gNodeInfo[i].currentState.levelNode.levelValue;//0x00:表示熄灭; 0xFF:表示打开;其他值表示led的亮度.
				break;
				case LIGHT_COLOUR_CTRL:
					pAckData[3+(i-StartMAC)*15+13] = gZigBeeObject.gNodeInfo[i].currentState.colourTempNode.colourTempValue;//0x00:表示白色; 0xD8:表示桔黄色;其他值表示led的色温.
					pAckData[3+(i-StartMAC)*15+14] = gZigBeeObject.gNodeInfo[i].currentState.colourTempNode.levelValue;//0x00:表示熄灭; 0xFF:表示打开;其他值表示led的亮度.
				break;
				default:
				break;
			}
		}
	}
	
	return(len);
}

/**************************************************************
* 名称 : QuerySlaveOneMac
* 功能 : 查询ZigBee的指定节点的信息.
*
* 参数 : pIeeeAddr    : in  : 要比较的 Ieee地址;
*	    pAckData     : out : 打包好的协议数据块数据;
* 返回 : len          :  打包后,协议的长度; 0:err;
*
* 备注 : 1.
**************************************************************/
UINT16  QuerySlaveOneMac(UINT8 *pIeeeAddr, UINT8 *pAckData)
{
	UINT8      tempU8;
	UINT16    len = 0;

	if( (pIeeeAddr == NULL) || (pAckData == NULL) ) {
		goto goto_QuerySlaveOneMac;
	}
	
	len = 16;
	tempU8 = SearchNode(pIeeeAddr);
	if( NODE_NUM_MAX <= tempU8 )
	{
		pAckData[0] = 0x12;//保存操作结果,没有匹配的短地址
		goto goto_QuerySlaveOneMac;
	}else{
		pAckData[0] = 0x00;//OK
	}
	
	memcpy(&pAckData[1], &(gZigBeeObject.gNodeInfo[tempU8].IeeeAddr[0]), 8);//MAC地址(8个字节)
	Little_uint16ToStr(&pAckData[9], gZigBeeObject.gNodeInfo[tempU8].deviceType);//节点的设备类型(2个字节)
	Little_uint16ToStr(&pAckData[11], gZigBeeObject.gNodeInfo[tempU8].nodeGroupAddr);//节点的组信息(2个字节)

	pAckData[13] = 0;//初始化为0
	/* 判断节点是否在线 */
	if( 0x0F == ((gZigBeeObject.gNodeInfo[tempU8].nodeIndicate) & 0x0F) ){
		ZIGBEE_ASW_PRINTF("on-line.");
		pAckData[13] |= 0x01;//该节点有Ieee地址、通信端口号、设备类型信息,并且在线,才标记为节点在线(bit0)
	}else{
		ZIGBEE_ASW_PRINTF("off-line.");
	}
	/* 判断节点储存的组地址是否已满 */
	if( NODE_GROUP_STORE_FULL_FLAG == ((gZigBeeObject.gNodeInfo[tempU8].nodeIndicate) & NODE_GROUP_STORE_FULL_FLAG)){
		ZIGBEE_ASW_PRINTF("-Group full.\n");
		pAckData[13] |= 0x02;//该节点储存的组已满(bit1)
	}else{
		ZIGBEE_ASW_PRINTF("-Group no full.\n");
	}
	

	switch(gZigBeeObject.gNodeInfo[tempU8].deviceType)
	{
		case LIGHT_ONOFF_CTRL:
			pAckData[14] = 0x00;//填充字节

			if( 0x01 == gZigBeeObject.gNodeInfo[tempU8].currentState.onOffNode.onOffValue ){
				pAckData[15] = 0x55;//当前状态为开
			}else{
				pAckData[15] = 0xAA;//当前状态为关
			}
		break;
		case LIGHT_LEVEL_CTRL:
			pAckData[14] = 0x00;//填充字节
			pAckData[15] = gZigBeeObject.gNodeInfo[tempU8].currentState.levelNode.levelValue;//0x00:表示熄灭; 0xFF:表示打开;其他值表示led的亮度.
		break;
		case LIGHT_COLOUR_CTRL:
			pAckData[14] = gZigBeeObject.gNodeInfo[tempU8].currentState.colourTempNode.colourTempValue;//0x00:表示白色; 0xD8:表示桔黄色;其他值表示led的色温.
			pAckData[15] = gZigBeeObject.gNodeInfo[tempU8].currentState.colourTempNode.levelValue;//0x00:表示熄灭; 0xFF:表示打开;其他值表示led的亮度.
		break;
		default:
		break;
	}

	ZIGBEE_ASW_PRINTF("\nQSOM: ");
	ZIGBEE_ASW_OUTSTR(pAckData, len);
	
goto_QuerySlaveOneMac:
	return(len);
}

/**************************************************************
* 名称 : u16QueryControllerInfo
* 功能 : 查询ZigBee的遥控器节点的信息.
*
* 参数 : pAckData     : out : 打包好的协议数据块数据;
*	    
* 返回 : len          :  打包后,协议的长度; 0:err;
*
* 备注 : 1.
**************************************************************/
UINT16  u16QueryControllerInfo(UINT8 *pAckData)
{
	UINT8      tempU8;
	UINT16    len = 0;

	if( pAckData == NULL ) {
		goto goto_u16QueryControllerInfo;
	}
	
	len = 15;
	if( 0x00 == gControllerInfo.validFlag)
	{
		pAckData[0] = 0x00;//保存操作结果,没有遥控器
		goto goto_u16QueryControllerInfo;
	}else{
		pAckData[0] = 0x01;//有遥控器
	}
	
	memcpy(&pAckData[1], gControllerInfo.IeeeAddr, 8);//遥控器的MAC地址(8个字节)
	Little_uint16ToStr(&pAckData[9], gControllerInfo.controllerType);//遥控器类型(2个字节)
	
goto_u16QueryControllerInfo:
	return(len);
}

/**************************************************************
* 名称 : ProtocolDevTypeParse
* 功能 : 解析协议的二级子设备的设备类型.
*
* 参数 :     iDataAddr: in : 协议中数据块的首地址;
*	    pProtocolData: in : 接收的协议数据的设备类型的首地址;
*	   	      ackBuf: in : 打包好的协议数据块数据;
*  			    err: in : 出错标记;
* 返回 : len  : 返回的应答数据包的长度,小于0x1000有效;
*
* 备注 : 1. 
**************************************************************/
UINT16  ProtocolDevTypeParse(UINT8 *pDataAddr,UINT8 *pProtocolData, UINT8 *ackBuf, UINT8 *err)
{
	UINT16 len = 0xFFFF;//默认无效

	if(err == NULL)  { goto goto_ProtocolDevTypeParse;  }

	*err = 0x00;//默认OK
	if( (pProtocolData == NULL) )
	{
		*err = 1;//参数错误
		goto goto_ProtocolDevTypeParse;
	}

	switch( Little_str2uint16(pProtocolData) )
	{
		case LIGHT_ONOFF_CTRL://开关LED
			len = ProtocolCmdTypeParse(pDataAddr, &pProtocolData[2], ackBuf, err);
		break;
		case LIGHT_LEVEL_CTRL://亮度LED
			len = ProtocolCmdTypeParse(pDataAddr, &pProtocolData[2], ackBuf, err);
		break;
		case LIGHT_COLOUR_CTRL://色温LED
			len = ProtocolCmdTypeParse(pDataAddr, &pProtocolData[2], ackBuf, err);
		break;
		case CONTROLLER_DEV_TYPE://遥控器
			len = ProtocolCmdTypeParse(pDataAddr, &pProtocolData[2], ackBuf, err);
		default:
			//*err = 0x02;//子设备类型错误
			ZIGBEE_ASW_PRINTF("-SubDevType err: %x.", Little_str2uint16(pProtocolData));
			ackBuf[0] = 0x20;//子设备类型错误
			ackBuf[1] = 0x20;//填充字节
			len = 2;
		break;
	}

goto_ProtocolDevTypeParse:
	return(len);
}

/**************************************************************
* 名称 : ProtocolCmdTypeParse
* 功能 : 解析协议的二级子命令的命令类型.
*
* 参数 :     iDataAddr: in : 协议中数据块的首地址;
*        pProtocolData: in : 接收的协议数据的命令字的首地址;
*	   	      ackBuf: in : 打包好的协议数据块数据;
*  			    err: in : 出错标记;
* 返回 : len  : 返回的应答数据包的长度,小于0x1000有效;
*
* 备注 : 1.
**************************************************************/
UINT16   ProtocolCmdTypeParse(UINT8 *pDataAddr, UINT8 *pProtocolData, UINT8 *ackBuf, UINT8 *err)//解析协议的二级子设备的命令字
{
	UINT16 len = 0xFFFF;//默认无效
	UINT8 tempNodeNum = NODE_NUM_MAX;//默认无效
	
	if(err == NULL)  { goto goto_ProtocolCmdTypeParse;  }

	*err = 0x00;//默认OK
	if( (pProtocolData == NULL) || (ackBuf == NULL) )
	{
		*err = 1;//参数错误
		goto goto_ProtocolCmdTypeParse;
	}
	
	ZIGBEE_ASW_PRINTF("-SubCmd:%x.", pProtocolData[0]);

	switch( pProtocolData[0] )//cmd 命令字
	{
		case 0x10://设置设备的开关状态
			ZIGBEE_ASW_PRINTF("-onOff:%x.\n", pProtocolData[1]);
		break;
		case 0x11://查询设备的开关状态
			len = 2;
			tempNodeNum = SearchNode(&pDataAddr[2]);//通过MAC地址获取节点编号
			if( NODE_NUM_MAX <= tempNodeNum )
			{
				ackBuf[0] = 0x12;//0x12:没有匹配的短地址
				ackBuf[1] = 0x12;//填充字节
				break;
			}else{
				ackBuf[0] = 0x00;//操作结果OK
				ackBuf[1] = gZigBeeObject.gNodeInfo[tempNodeNum].currentState.onOffNode.onOffValue;
			}
		break;
		
		case 0x18://设置设备的亮度值
			ZIGBEE_ASW_PRINTF("-level:%x.\n", pProtocolData[1]);
		break;
		case 0x19://查询设备的亮度值
			len = 2;
			tempNodeNum = SearchNode(&pDataAddr[2]);//通过MAC地址获取节点编号
			if( NODE_NUM_MAX <= tempNodeNum )
			{
				ackBuf[0] = 0x12;//0x12:没有匹配的短地址
				ackBuf[1] = 0x12;//填充字节
				break;
			}else{
				ackBuf[0] = 0x00;//操作结果OK
				ackBuf[1] = gZigBeeObject.gNodeInfo[tempNodeNum].currentState.levelNode.levelValue;
			}
		break;
		
		case 0x20://设置设备的色温值
			ZIGBEE_ASW_PRINTF("-colourT:%x.\n", pProtocolData[1]);
		break;
		case 0x21://查询设备的色温值
			len = 2;
			tempNodeNum = SearchNode(&pDataAddr[2]);//通过MAC地址获取节点编号
			if( NODE_NUM_MAX <= tempNodeNum )
			{
				ackBuf[0] = 0x12;//0x12:没有匹配的短地址
				ackBuf[1] = 0x12;//填充字节
				break;
			}else{
				ackBuf[0] = 0x00;//操作结果OK
				ackBuf[1] = gZigBeeObject.gNodeInfo[tempNodeNum].currentState.colourTempNode.colourTempValue;
			}
		break;
		
		default:
			ZIGBEE_ASW_PRINTF("-SubCmd err:%x.\n", pProtocolData[0]);
			ackBuf[0] = 0x21;//子命令类型错误
			ackBuf[1] = 0x21;//填充字节
			len = 2;
		break;
	}

goto_ProtocolCmdTypeParse:
	return(len);
}

/*****************************************************
* 名称 : SendUartCommand
* 功能 : wifi模块 通过串口 发送数据到 ZigBee 模块.
*
* 参数 : iBuf : in : 串口收到的 ZigBee协议包 首地址;
*               iLen : in : 协议包长度;
* 返回 : 无
*
* 备注 : 1.发送的数据是没有转义的数据.
*****************************************************/
void SendUartCommand(const UINT8 * iBuf, const UINT16 iLen)
{
	UCHAR    pCmdBuf[96];
	UINT8     tCheckSum, tempU8;
	UINT16   tLen;

	if(iBuf == NULL) 
	{  
		ZIGBEE_ASW_PRINTF("SendUartCommand : iBuf == NULL.\n");  
		goto goto_SendUartCommand;
	}
	if(iLen < 7)     
	{
		ZIGBEE_ASW_PRINTF("SendUartCommand : iLen < 7, iLen:%d.\n", iLen);  
		goto goto_SendUartCommand;
	}
	if((iBuf[0] !=0x01) || (iBuf[iLen-1] != 0x03))
	{
		ZIGBEE_ASW_PRINTF("SendUartCommand : head or end err. head:%d, end:%d.\n", iBuf[0], iBuf[iLen-1]);
		goto goto_SendUartCommand;
	}

	//计算校验码
	tempU8 = CheckSum(iBuf, iLen-1);
	tCheckSum = tempU8 ^ iBuf[5];

	//转义
	tLen = CodingEscapeString(pCmdBuf, iBuf, iLen, tCheckSum);
	
//	ZIGBEE_ASW_PRINTF("ZigBee send:");
//	ZIGBEE_ASW_OUTSTR(pCmdBuf, tLen);
//	ZIGBEE_ASW_PRINTF(".\n");

	gZigBeeObject.cmdAckFlag  = 0xFF;//发送的每个命令,都会收到0x8000的应答,这个是应答的标志,0:OK.
	gZigBeeObject.ableCtrlFlag = UnableCtrl;//禁止上层发送控制命令标记

//串口发送延时
#if 0
	{
		UINT32   tt;
		UINT32 ssDelay = GetMsTimer();
		for(tt = 0xFFFFF; tt > 0x02; tt--);
		while(1)
		{
			tt = GetMsTimer();
			if(tt - ssDelay > 12)
			{
				break;
			}
		}
	}
#endif

	gZigBeeObject.sendCmdTime  = GetMsTimer(); //发送命令的时间(单位:ms)
	gZigBeeObject.receUartTime = gZigBeeObject.sendCmdTime;//接收命令的时间(单位:ms)
	
	UART_PutBytes(pCmdBuf, tLen);//ZigBeeUart(pCmdBuf, tLen);
	//for(i = 0; i < tLen; i++)
	//{
	//	UART_PutChar( pCmdBuf[i] );
	//}

goto_SendUartCommand:
	return;
}

/**************************************************************
* 名称 : StateJump
* 功能 : 一级状态跳转.
*
* 参数 : iState : in : 跳转到下一个状态值;
* 返回 : 无
*
* 备注 : 1. 
**************************************************************/
void  StateJump(DeviceZigBee_State iState)
{
	ZIGBEE_ASW_PRINTF("S_Jump:to %d.\n", iState);
	gZigBeeObject.state = iState;
	gZigBeeObject.sequence = 0;
}

/**************************************************************
* 名称 : ClearNodeAllFlag
* 功能 : 清除节点的所有标记位,让节点重新获取所有数据.
*
* 参数 : 无;
* 返回 : 无;
*
* 备注 : 1. 
**************************************************************/
void  ClearNodeAllFlag(void)
{
	UINT8 i, tempNodeNum;

	tempNodeNum = GetNodeNum();//获取节点的个数
	for(i=0;i<tempNodeNum;i++)
	{
		gZigBeeObject.gNodeInfo[i].nodeIndicate = 0x00;//清除节点所有标记
	}
}

/**************************************************************
* 名称 : ClearNodeQueryGroupFlag
* 功能 : 清除删除组内的 节点已查询组的标记位.
*
* 参数 : iDelGroupNum : in :删除组的组编号;
* 返回 : 无;
*
* 备注 : 1. 
**************************************************************/
void	ClearNodeQueryGroupFlag(UINT8 iDelGroupNum)
{
	UINT8 	i, nodeNum;
	UINT16	tempDelGroupAddr;

	if(iDelGroupNum >= 16){ goto goto_ClearNodeQueryGroupFlag;}//参数错误,直接退出
	
	tempDelGroupAddr = ( (UINT16)0x01 ) << iDelGroupNum;
	nodeNum = GetNodeNum();//获得节点数目

	for(i=0;i<nodeNum;i++)
	{
		if( tempDelGroupAddr == ((gZigBeeObject.gNodeInfo[i].nodeGroupAddr) & tempDelGroupAddr) )
		{
			//设置 刷新标志
			gZigBeeObject.gNodeInfo[i].nodeIndicate &= (~(UINT8)NODE_OBTAIN_GROUP_ADDR_FLAG);//该节点有组的操作,所以要标记该节点没有查询组
		}
	}

goto_ClearNodeQueryGroupFlag:
	return;
}

/**************************************************************
* 名称 : CodingEscapeString
* 功能 : 将原始协议包 转义.
*
* 参数 : pDestBuff: out : 保存转义后的信息 首地址;
*        pSrcBuff : in : 原始数据的 首地址;
*        iLen     : in : 协议包长度;
*        iCheckSum: in : 校验码的值.
* 返回 : outLen   : 转义后的消息长度; 0:出错
*
* 备注 : 1.校验码在原始数据pBuff[5]的位置;
**************************************************************/
UINT16  CodingEscapeString(UINT8 *pDestBuff, const UINT8 *pSrcBuff, const UINT16 iLen, UINT8 iCheckSum)
{
	UINT16    i, outLen;

	if((pDestBuff == NULL) || (pSrcBuff == NULL) || (iLen < 7))
	{
		return 0;//参数错误
	}

	if((pSrcBuff[0] !=0x01) || (pSrcBuff[iLen-1] != 0x03))
	{
		return 0;//参数错误
	}

	pDestBuff[0] = 0x01;//包头
	for(i = 1,outLen = 1; i <= 4; i++)
	{
		if(pSrcBuff[i] < 0x10)
		{
			pDestBuff[outLen] = 0x02;  outLen ++;
			pDestBuff[outLen] = pSrcBuff[i] ^ 0x10;
		} else {
			pDestBuff[outLen] = pSrcBuff[i];
		}
		outLen ++;
	}
	//转义校验码  //校验码在原始数据pBuff[5]的位置;
	if(iCheckSum < 0x10)
	{
		pDestBuff[outLen] = 0x02;  outLen ++;
		pDestBuff[outLen] = iCheckSum ^ 0x10;
	} else {
		pDestBuff[outLen] = iCheckSum;
	}
	outLen ++;

	for(i = 6; i < (iLen-1); i++)
	{
		if(pSrcBuff[i] < 0x10)
		{
			pDestBuff[outLen] = 0x02;  outLen ++;
			pDestBuff[outLen] = pSrcBuff[i] ^ 0x10;
		} else {
			pDestBuff[outLen] = pSrcBuff[i];
		}
		outLen ++;
	}
	pDestBuff[outLen] = 0x03;//包尾
	outLen ++;

	return(outLen);
}

/**************************************************************
* 名称 : DecodeEscapeString
* 功能 : 解码 转义的消息.
*
* 参数 : iBuf : in : 串口收到的 ZigBee协议包 首地址;
*        iLen : in : 协议包长度;
* 返回 : outLen   : 转义后的消息长度; 0:出错
*
* 备注 : 1.
**************************************************************/
UINT16  DecodeEscapeString(UINT8 *pBuff, const UINT16 iLen)
{
	UINT16    i, outLen;

	if(pBuff == NULL)
	{
		ZIGBEE_ASW_PRINTF("EscapeString : iBuf == NULL.\n");
		return 0;//参数错误
	}

	for(i = 0, outLen = 0; i < iLen; i++)
	{
		if(pBuff[i] == 0x02)
		{
			i++;
			pBuff[outLen] = pBuff[i]^0x10;
		} else {
			if(i != outLen)
			{
				pBuff[outLen] = pBuff[i];
			}
		}
		outLen++;
	}

	return(outLen);
}

/**************************************************************
* 名称 : RefreshFlashGroupFlag
* 功能 : 刷新 组名
*
* 参数 : 
* 返回 :
*
* 备注 : 1. 最多只查询8组,编号从 0..7.
*        1.   0x1D400 - 0x1D43F  : 第一组的组名数据(组编号为0) 64字节
*        2.   0x1D440 - 0x1D47F  : 第二组的组名数据(组编号为1) 64字节
*        3.   0x1D480 - 0x1D4BF  : 第三组的组名数据(组编号为2) 64字节
*        4.   0x1D4C0 - 0x1D4FF  : 第四组的组名数据(组编号为3) 64字节
*        5.   0x1D500 - 0x1D53F  : 第五组的组名数据(组编号为4) 64字节
*        6.   0x1D540 - 0x1D57F  : 第六组的组名数据(组编号为5) 64字节
*        7.   0x1D580 - 0x1D5BF  : 第七组的组名数据(组编号为6) 64字节
*        8.   0x1D5C0 - 0x1D5FF  : 第八组的组名数据(组编号为7) 64字节
*        9.   0x1D600 - 0x1D63F  : 第九组的组名数据(组编号为8) 64字节
*       10.   0x1D640 - 0x1D67F  : 第十组的组名数据(组编号为9) 64字节
*       11.   0x1D680 - 0x1D6BF  : 第十一组的组名数据(组编号为10) 64字节
*       12.   0x1D6C0 - 0x1D6FF  : 第十二组的组名数据(组编号为11) 64字节
*       13.   0x1D700 - 0x1D73F  : 第十三组的组名数据(组编号为12) 64字节
*       14.   0x1D740 - 0x1D77F  : 第十四组的组名数据(组编号为13) 64字节
*       15.   0x1D780 - 0x1D7BF  : 第十五组的组名数据(组编号为14) 64字节
*       16.   0x1D7C0 - 0x1D7FF  : 第十六组的组名数据(组编号为15) 64字节
**************************************************************/
void  RefreshFlashGroupFlag(void)
{
	UINT8    i, *flashRwAddr;

	flashRwAddr = IoTpAd.flash_rw_buf;//读取flash的缓存
	for(i = 0; i < 16; i++)
	{
		spi_flash_read(0x1D400 + (i<<6), flashRwAddr, 64);  flashRwAddr[64] = 0;//结束字符
		if( (flashRwAddr[0] == 0) || 
		     (flashRwAddr[0] != (flashRwAddr[1]^0xAA)) ||
		     (flashRwAddr[0] != strlen(&flashRwAddr[2])) )//长度为 0 || 如果长度错误 || 记录长度与实际长度不一样
		{
			flashGroupData &= (~( ((UINT16)0x01)<<i ));//刷新组信息
		} else {
			flashGroupData |= ( ((UINT16)0x01)<<i );//刷新组信息
		}
	}
}

/**************************************************************
* 名称 : ReadGroupName
* 功能 : 读取 组名
*
* 参数 : pBuff : out   : 要保存组名的缓存指针;
*        ioNum : in_out: 传入查询组名的开始编号,传出查询的组个数;
*        maxLen : in   : 存储数据的最大长度;
* 返回 : outLen        : 查询结果占用的数据长度. 0:错误;
*
* 备注 : 1. 最多只查询8组,编号从 0..7.
*        1.   0x1D400 - 0x1D43F  : 第一组的组名数据(组编号为0) 64字节
*        2.   0x1D440 - 0x1D47F  : 第二组的组名数据(组编号为1) 64字节
*        3.   0x1D480 - 0x1D4BF  : 第三组的组名数据(组编号为2) 64字节
*        4.   0x1D4C0 - 0x1D4FF  : 第四组的组名数据(组编号为3) 64字节
*        5.   0x1D500 - 0x1D53F  : 第五组的组名数据(组编号为4) 64字节
*        6.   0x1D540 - 0x1D57F  : 第六组的组名数据(组编号为5) 64字节
*        7.   0x1D580 - 0x1D5BF  : 第七组的组名数据(组编号为6) 64字节
*        8.   0x1D5C0 - 0x1D5FF  : 第八组的组名数据(组编号为7) 64字节
*        9.   0x1D600 - 0x1D63F  : 第九组的组名数据(组编号为8) 64字节
*       10.   0x1D640 - 0x1D67F  : 第十组的组名数据(组编号为9) 64字节
*       11.   0x1D680 - 0x1D6BF  : 第十一组的组名数据(组编号为10) 64字节
*       12.   0x1D6C0 - 0x1D6FF  : 第十二组的组名数据(组编号为11) 64字节
*       13.   0x1D700 - 0x1D73F  : 第十三组的组名数据(组编号为12) 64字节
*       14.   0x1D740 - 0x1D77F  : 第十四组的组名数据(组编号为13) 64字节
*       15.   0x1D780 - 0x1D7BF  : 第十五组的组名数据(组编号为14) 64字节
*       16.   0x1D7C0 - 0x1D7FF  : 第十六组的组名数据(组编号为15) 64字节
**************************************************************/
UINT16  ReadGroupName(UINT8 *pBuff, UINT8 *ioNum, const UINT16 maxLen)
{
	UINT8    startNum, num, strLen, tempU8;
	UINT16   i, outLen;
	UINT8   *bufAddr;
	UINT8   *flashRwAddr;

	if((pBuff == NULL) || (ioNum == NULL) || (maxLen < 16))
	{
		return(0);
	}
	startNum = *ioNum;
	if(startNum >= 16)  {  return(0);  }

	flashRwAddr = IoTpAd.flash_rw_buf;//读取flash的缓存
	bufAddr     = &pBuff[16];
	outLen      = 16;
	num         = 0;
	for(i = startNum; i < 16; i++)
	{
		spi_flash_read(0x1D400 + (i<<6), flashRwAddr, 64);  flashRwAddr[64] = 0;//结束字符
		strLen = flashRwAddr[0];
		if( (strLen == 0) || (strLen != (flashRwAddr[1]^0xAA)) || 
			(strLen != strlen(&flashRwAddr[2])) )//长度为 0 || 如果长度错误 || 记录长度与实际长度不一样
		{
			flashGroupData &= (~( ((UINT16)0x01)<<i ));//刷新组信息
			pBuff[num] = 0;   num++;
		} else {
			flashGroupData |= ( ((UINT16)0x01)<<i );//刷新组信息
			if((outLen + (strLen + 1)) <= maxLen)//还有空间保存数据
			{
				pBuff[num] = strLen+1;  num ++;  //包含 结束字符 0x00

				memcpy(bufAddr, &flashRwAddr[2], (strLen+1));
				bufAddr += (strLen+1);    outLen += (strLen+1);
			} else {//空间不够了,直接跳出
				break;
			}
		}
	}
	if(num == 0)  {  return(0);  }//第一个组名就超出缓存长度了

	*ioNum = num;
	//---- 查询完了,要将组名开始位置从 pBuff[16] 移到正确位置 ----
	if(outLen > 16)//获取了字符串
	{
		if(num < 16)//查询的组数 小于16,需要将数据移位置
		{
			tempU8 = 16 - num;
			for(i = 16; i < outLen; i++)
			{
				pBuff[i-tempU8] = pBuff[i];
			}
			outLen -= tempU8;
		}
	} else { //没有一组有数据,要处理outLen值
		outLen = num;//查询了几组 组名, outLen 才有 几个字节.
	}

	return(outLen);
}

/**************************************************************
* 名称 : WriteGroupName
* 功能 : 写一个 组名.
*
* 参数 : GroupNum : in : 组 编号(0..15有效);
*      pName    : in : 组名的字符串(包含结束字符0x00);
*      flag     : in : 操作标志. 0x55: 创建组; 0xAA:修改组名;
* 返回 : err   : 错误标志. 0:OK;
*
* 备注 : 1.
**************************************************************/
UINT8  WriteGroupName(const UINT8 GroupNum, const UINT8 *pName, const UINT8 flag)
{
	UINT16  tLen;
	UINT8   *flashRwAddr;

	if( (GroupNum >= 16) || (pName == NULL) || ((flag != 0x55) && (flag != 0xAA)) )
	{
		return(1);//参数错误
	}
	if( (flag == 0x55) && ((flashGroupData & ( ((UINT16)0x01)<<GroupNum )) != 0) )//创建组 && 组已存在
	{
		return(2);//组编号错误
	}
	if( (flag == 0xAA) && ((flashGroupData & ( ((UINT16)0x01)<<GroupNum )) == 0) )//修改组名 && 组不存在
	{
		return(2);//组编号错误
	}
	tLen = strlen(pName);
	if((tLen == 0) || (tLen > 62))
	{
		return(3);//组名长度错误
	}
	flashGroupData |= ( ((UINT16)0x01)<<GroupNum );

	flashRwAddr = IoTpAd.flash_rw_buf;//读取flash的缓存

	flashRwAddr[0] = tLen;    flashRwAddr[1] = tLen^0xAA;
	memcpy(&flashRwAddr[2], pName, tLen+1);

	spi_flash_write(0x1D400 + (GroupNum<<6), flashRwAddr, 64);

	return(0);
}

/**************************************************************
* 名称 : DelGroupName
* 功能 : 删除 一个 组.
*
* 参数 : GroupNum : in : 组 编号(0..15有效);
*      pName    : in : 组名的字符串(包含结束字符0x00);
* 返回 : err   : 错误标志. 0:OK;
*
* 备注 : 1.
**************************************************************/
UINT8  DelGroupName(const UINT8 GroupNum)
{
	UINT8   *flashRwAddr;

	if(GroupNum >= 16)
	{
		return(1);//参数错误
	}

	flashGroupData &= (~( ((UINT16)0x01)<<GroupNum ));//刷新组信息

	flashRwAddr = IoTpAd.flash_rw_buf;//读取flash的缓存
	flashRwAddr[0] = 0;    flashRwAddr[1] = 0;  flashRwAddr[2] = 0;
	spi_flash_write(0x1D400 + (GroupNum<<6), flashRwAddr, 4);

	return(0);
}

/**************************************************************
* 名称 : CheckGroupAddr
* 功能 : 检查组地址的有效性.
*
* 参数 : iGroupAddr	: in : 16位的组地址;
* 返回 : flag   : 有效标志; 0:有效组地址; 0xFF:无效组地址,参数错误;
*
* 备注 : 1. iGroupAddr -- 组地址是16位的数据,每一位标记为一个组
**************************************************************/
UINT8  CheckGroupAddr(UINT16 iGroupAddr)
{
	UINT8   flag;
	
	flag = 0xFF;//默认无效,与出错
	if( 1 == CountBitUint(iGroupAddr) ){//组地址只有一位为1
		flag = 0;//有效组地址
	}

	return(flag);
}

/**************************************************************
* 名称 : CheckUpGroupNum
* 功能 : 检查上层要操作的组是否属于在线节点的组中.
*
* 参数 : iUpGroupNum	: in : 上层要操作的组编号;
* 返回 : err: 0:有效 1:无效或者参数错误
*
* 备注 : 1.
**************************************************************/
UINT8  CheckUpGroupNum(UINT8 iUpGroupNum)
{
	UINT8   err,i,tempNodeNum;
	UINT16 tempGroupList;
	
	err = 1;//默认无效或者参数错误
	if(iUpGroupNum >= 16) { goto  goto_CheckUpGroupNumValid;}

	tempGroupList = 0;//节点的所有组按位或的结果初始化为0
	tempNodeNum = GetNodeNum();//获取节点数目

	/* 获取存在的在线节点的所有组信息按位或的结果 */
	for(i=0;i<tempNodeNum;i++)
	{
		if( ((UINT8)NODE_OBTAIN_ONLINE_FLAG) == (gZigBeeObject.gNodeInfo[i].nodeIndicate & ((UINT8)NODE_OBTAIN_ONLINE_FLAG)) )
		{//节点在线,才把该节点的组信息按位或
			tempGroupList |= gZigBeeObject.gNodeInfo[i].nodeGroupAddr;
		}
	}

	/* 上层要操作的组编号是否属于在线节点的所有组按位或的结果里面 */
	if( 0 != (tempGroupList & (((UINT16)0x01) << iUpGroupNum)) )
	{
		err = 0;//有效,表明上层发送的组编号属于在线节点的所有组信息按位或的结果里面
	}

goto_CheckUpGroupNumValid:
	return(err);
}

/**************************************************************
* 名称 : CheckGroupExist
* 功能 : 检查场景所在的组是否还存在.
*
* 参数 : iUpGroupNum	: in : 上层要操作的组编号;
* 返回 : err: 0:检测到了场景所在的组不存在,并且执行了删除场景操作
*		    1:无操作或者参数错误
*
* 备注 : 1.
**************************************************************/
UINT8  CheckGroupExist(UINT8 iUpGroupNum)
{
	UINT8   err, i;
	UINT8   *flashRwAddr;
	UINT16  tempGroupAddr;
	
	err = 1;//默认无操作或者参数错误
	if(iUpGroupNum >= 16) { goto  goto_CheckGroupExist;}

	tempGroupAddr = ((UINT16)0x01) << iUpGroupNum;
	if( tempGroupAddr == (flashGroupData & tempGroupAddr) )
	{//该组存在,不做任何处理
		err = 1; 
		goto goto_CheckGroupExist;
	}else{//该组不存在,删除跟该组相关联的场景
		for(i=0;i<16;i++)
		{
			if( flashSceneMatchGroup[i] == iUpGroupNum )//找到跟该组相关联的场景
			{
				DelSceneName(i);//删除该场景
			}
		}
		err = 0;
	}

goto_CheckGroupExist:
	return(err);
}

/**************************************************************
* 名称 : RefreshFlashSceneMatchGroup
* 功能 : 刷新场景对应的组编号.
*
* 参数 : 
* 返回 : 
*
* 备注 : 1. 最多只查询8组,编号从 0..15.
*        1.   0x1D800 - 0x1D83F  : 第一组的组名数据(组编号为0) 64字节
*        2.   0x1D840 - 0x1D87F  : 第二组的组名数据(组编号为1) 64字节
*        3.   0x1D880 - 0x1D8BF  : 第三组的组名数据(组编号为2) 64字节
*        4.   0x1D8C0 - 0x1D8FF  : 第四组的组名数据(组编号为3) 64字节
*        5.   0x1D900 - 0x1D93F  : 第五组的组名数据(组编号为4) 64字节
*        6.   0x1D940 - 0x1D97F  : 第六组的组名数据(组编号为5) 64字节
*        7.   0x1D980 - 0x1D9BF  : 第七组的组名数据(组编号为6) 64字节
*        8.   0x1D9C0 - 0x1D9FF  : 第八组的组名数据(组编号为7) 64字节
*        9.   0x1DA00 - 0x1DA3F  : 第九组的组名数据(组编号为8) 64字节
*       10.   0x1DA40 - 0x1DA7F  : 第十组的组名数据(组编号为9) 64字节
*       11.   0x1DA80 - 0x1DABF  : 第十一组的组名数据(组编号为10) 64字节
*       12.   0x1DAC0 - 0x1DAFF  : 第十二组的组名数据(组编号为11) 64字节
*       13.   0x1DB00 - 0x1DB3F  : 第十三组的组名数据(组编号为12) 64字节
*       14.   0x1DB40 - 0x1DB7F  : 第十四组的组名数据(组编号为13) 64字节
*       15.   0x1DB80 - 0x1DBBF  : 第十五组的组名数据(组编号为14) 64字节
*       16.   0x1DBC0 - 0x1DBFF  : 第十六组的组名数据(组编号为15) 64字节
*	  
*     注释:每一个场景flash中储存的格式: 组编号+场景名长度+场景名长度异或0xAA+场景名数据 
**************************************************************/
void  RefreshFlashSceneMatchGroup(void)
{
	UINT8    i, *flashRwAddr;

	flashRwAddr = IoTpAd.flash_rw_buf;//读取flash的缓存
	for(i = 0; i < 16; i++)
	{
		spi_flash_read(0x1D800 + (i<<6), flashRwAddr, 64);  flashRwAddr[64] = 0;//结束字符
		if( (flashRwAddr[0] >= 16) ||
		     (flashRwAddr[1] == 0) || 
		     (flashRwAddr[1] != (flashRwAddr[2]^0xAA)) ||
		     (flashRwAddr[1] != strlen(&flashRwAddr[3])) )//组编号>= 16 || 长度为 0 || 如果长度错误 || 记录长度与实际长度不一样
		{
			flashSceneMatchGroup[i] = 0xFF;
		} else {
			flashSceneMatchGroup[i] = flashRwAddr[0];
		}
	}
}

/**************************************************************
* 名称 : ReadSceneName
* 功能 : 读取 场景名
*
* 参数 : pBuff : out   : 要保存场景的缓存指针;
*        ioNum : in_out: 传入查询场景名的开始编号,传出查询的组个数;
*        maxLen : in   : 存储数据的最大长度;
* 返回 : len           : 查询结果占用的数据长度. 0:错误;
*
* 备注 : 1. 最多只查询8组,编号从 0..15.
*        1.   0x1D800 - 0x1D83F  : 第一组的组名数据(组编号为0) 64字节
*        2.   0x1D840 - 0x1D87F  : 第二组的组名数据(组编号为1) 64字节
*        3.   0x1D880 - 0x1D8BF  : 第三组的组名数据(组编号为2) 64字节
*        4.   0x1D8C0 - 0x1D8FF  : 第四组的组名数据(组编号为3) 64字节
*        5.   0x1D900 - 0x1D93F  : 第五组的组名数据(组编号为4) 64字节
*        6.   0x1D940 - 0x1D97F  : 第六组的组名数据(组编号为5) 64字节
*        7.   0x1D980 - 0x1D9BF  : 第七组的组名数据(组编号为6) 64字节
*        8.   0x1D9C0 - 0x1D9FF  : 第八组的组名数据(组编号为7) 64字节
*        9.   0x1DA00 - 0x1DA3F  : 第九组的组名数据(组编号为8) 64字节
*       10.   0x1DA40 - 0x1DA7F  : 第十组的组名数据(组编号为9) 64字节
*       11.   0x1DA80 - 0x1DABF  : 第十一组的组名数据(组编号为10) 64字节
*       12.   0x1DAC0 - 0x1DAFF  : 第十二组的组名数据(组编号为11) 64字节
*       13.   0x1DB00 - 0x1DB3F  : 第十三组的组名数据(组编号为12) 64字节
*       14.   0x1DB40 - 0x1DB7F  : 第十四组的组名数据(组编号为13) 64字节
*       15.   0x1DB80 - 0x1DBBF  : 第十五组的组名数据(组编号为14) 64字节
*       16.   0x1DBC0 - 0x1DBFF  : 第十六组的组名数据(组编号为15) 64字节
*	  
*     注释:每一个场景flash中储存的格式: 组编号+场景名长度+场景名长度异或0xAA+场景名数据 
**************************************************************/
UINT16  ReadSceneName(UINT8 *pBuff, UINT8 *ioNum, const UINT16 maxLen)
{
	UINT8    startNum, num, strLen, tempU8;
	UINT16   i, outLen;
	UINT8   *bufAddr;
	UINT8   *flashRwAddr;

	if((pBuff == NULL) || (ioNum == NULL) || (maxLen < 16))
	{
		return(0);
	}
	startNum = *ioNum;
	if(startNum >= 16)  {  return(0);  }

	flashRwAddr = IoTpAd.flash_rw_buf;//读取flash的缓存
	bufAddr     = &pBuff[32];
	outLen      = 32;
	num         = 0;
	for(i = startNum; i < 16; i++)
	{
		spi_flash_read(0x1D800 + (i<<6), flashRwAddr, 64);  flashRwAddr[64] = 0;//结束字符
		strLen = flashRwAddr[1];
		if( (flashRwAddr[0] >= 16) ||
		     (strLen == 0) || 
		     (strLen != (flashRwAddr[2]^0xAA)) || 
		     (strLen != strlen(&flashRwAddr[3])) )//组编号>= 16 || 长度为 0 || 如果长度错误 || 记录长度与实际长度不一样
		{
			pBuff[num++] = 0xFF; pBuff[num++] = 0;
		} else {
			if((outLen + (strLen + 1)) <= maxLen)//还有空间保存数据
			{
				pBuff[num++] = flashRwAddr[0];//场景对应的 组编号
				pBuff[num++] = strLen+1;//包含 结束字符 0x00

				memcpy(bufAddr, &flashRwAddr[3], (strLen+1));
				bufAddr += (strLen+1);    outLen += (strLen+1);
			} else {//空间不够了,直接跳出
				break;
			}
		}
	}
	if(num == 0)  {  return(0);  }//第一个场景名就超出缓存长度了

	*ioNum = num>>1;//一个场景包括组编号和场景编号,所以要除以2才是真正的场景数量
	//---- 查询完了,要将场景名开始位置从 pBuff[32] 移到正确位置 ----
	if(outLen > 32)//获取了字符串
	{
		if(num < 32)//查询的场景数 小于16,需要将数据移位置
		{
			tempU8 = 32 - num;
			for(i = 32; i < outLen; i++)
			{
				pBuff[i-tempU8] = pBuff[i];
			}
			outLen -= tempU8;
		}
	} else { //没有一组有数据,要处理outLen值
		outLen = num;//查询了几组 组名, outLen 才有 几个字节.
	}

	return(outLen);
}

/**************************************************************
* 名称 : WriteSceneName
* 功能 : 写一个 场景名.
*
* 参数 : GroupNum : in : 组 编号(0..15有效);
*	    SceneNum : in : 场景 编号(0..15有效);
*        pName    : in : 场景名的字符串(包含结束字符0x00);
*        flag     : in : 操作标志. 0x55: 创建场景; 0xAA:修改场景名;
* 返回 : err   : 错误标志. 0:OK;
*
* 备注 : 1.
**************************************************************/
UINT8  WriteSceneName(const UINT8 GroupNum, const UINT8 SceneNum, const UINT8 *pName, const UINT8 flag)
{
	UINT16  tLen,tempSceneNameLen;
	UINT8   *flashRwAddr;

	if( (SceneNum >= 16) || (pName == NULL) || ((flag != 0x55) && (flag != 0xAA)) )
	{
		return(1);//参数错误
	}

	tempSceneNameLen = GetSceneNameLen(SceneNum);
	if( 0xFF == tempSceneNameLen )
	{
		return(1);//参数错误
	}

	if( 0 == (flashGroupData & (((UINT16)0x01)<<GroupNum)) )//组不存在
	{
		return(2);//组编号错误
	}
	
	if( (flag == 0x55) && (tempSceneNameLen != 0) )//创建场景 && 场景已存在
	{
		return(2);//场景编号错误
	}
	if( (flag == 0xAA) && (tempSceneNameLen == 0) )//修改场景名 && 场景不存在
	{
		return(2);//场景编号错误
	}
	tLen = strlen(pName);
	if((tLen == 0) || (tLen > 61))
	{
		return(3);//场景名长度错误
	}
	flashRwAddr = IoTpAd.flash_rw_buf;//读取flash的缓存

	flashRwAddr[0] = GroupNum;
	flashRwAddr[1] = tLen;    flashRwAddr[2] = tLen^0xAA;
	memcpy(&flashRwAddr[3], pName, tLen+1);
	spi_flash_write(0x1D800 + (SceneNum<<6), flashRwAddr, 64);
	flashSceneMatchGroup[SceneNum] = GroupNum;//储存场景对应的 组编号
	
	return(0);
}

/**************************************************************
* 名称 : DelSceneName
* 功能 : 删除 一个 场景.
*
* 参数 : SceneNum : in : 场景 编号(0..15有效);
*    
* 返回 : 
*
* 备注 : 1.
**************************************************************/
UINT8  DelSceneName(const UINT8 SceneNum)
{
	UINT8   *flashRwAddr;

	if(SceneNum >= 16)
	{
		return(1);//参数错误
	}

	flashRwAddr = IoTpAd.flash_rw_buf;//读取flash的缓存
	flashRwAddr[0] = 0xFF;   flashRwAddr[1] = 0;  flashRwAddr[2] = 0;
	spi_flash_write(0x1D800 + (SceneNum<<6), flashRwAddr, 4);
	flashSceneMatchGroup[SceneNum] = 0xFF;//清除场景对应的 组编号
	
	return(0);
}

/**************************************************************
* 名称 : GetSceneNameLen
* 功能 : 通过场景编号,获取对应的场景名的长度.
*
* 参数 : sceneNum : in : 场景 编号(0..15有效);
*        
* 返回 : len   : 0 - 60 ;0xFF:参数错误
*
* 备注 : 1.
**************************************************************/
UINT8  GetSceneNameLen(const UINT8 SceneNum)
{
	UINT8   *flashRwAddr, len;

	len = 0xFF;//默认参数错误
	if(SceneNum >= 16){ goto goto_GetSceneNameLen; }//参数错误

	flashRwAddr = IoTpAd.flash_rw_buf;//读取flash的缓存
	spi_flash_read(0x1D800 + (SceneNum<<6), flashRwAddr, 64); flashRwAddr[64] = 0;//结束字符

	if( (flashRwAddr[0] >= 16) ||
	     (flashRwAddr[1] == 0) || 
	     (flashRwAddr[1] != (flashRwAddr[2]^0xAA)) ||
	     (flashRwAddr[1] != strlen(&flashRwAddr[3])) )//组编号>= 16 || 长度为 0 || 如果长度错误 || 记录长度与实际长度不一样
	{
		len = 0;
	}else{
		len = flashRwAddr[1];
	}

goto_GetSceneNameLen:
	return(len);
}


/**************************************************************
* 名称 : CheckSum
* 功能 : 消息 校验
*
* 参数 : pBuff : in_out :  要校验的缓存指针;
*        iLen  : in :      要校验的数据个数;
* 返回 : sum   : 计算得到的校验码;
*
* 备注 : 1. 检验和 (除了 包头, 包尾, 其他所有数据的XOR)(经验的数据
*            是原始数据,不是转义了的数据)
*        2. pBuff[0] 是包头(0x01),计算校验码时,要剔除.
**************************************************************/
UINT8  CheckSum(UINT8 *pBuff, const UINT16 iLen)
{
	UINT8     tempU8;
	UINT16    i;

	if((pBuff == NULL) || (iLen <= 1))
	{
		return(0);
	}

	for(i = 1, tempU8 = 0; i < iLen; i++)
	{
		tempU8 ^= pBuff[i];
	}

	return(tempU8);
}

#endif
