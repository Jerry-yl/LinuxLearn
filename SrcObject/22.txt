***********************************/
UINT8  CheckGroupExist(UINT8 iUpGroupNum)
{
	UINT8   err, i;
	UINT8   *flashRwAddr;
	UINT16  tempGroupAddr;
	
	err = 1;//默认无操作或者参数错误
	if(iUpGroupNum >= 16) { goto  goto_CheckGroupExist;}

	tempGroupAddr = ((UINT16)0x01) << iUpGroupNum;
	if( tempGroupAddr == (flashGroupData & tempGroupAddr) )
	{//该组存在,不做任何处理
		err = 1; 
		goto goto_CheckGroupExist;
	}else{//该组不存在,删除跟该组相关联的场景
		for(i=0;i<16;i++)
		{
			if( flashSceneMatchGroup[i] == iUpGroupNum )//找到跟该组相关联的场景
			{
				DelSceneName(i);//删除该场景
			}	
		}
		err = 0;
	}

goto_CheckGroupExist:
	return(err);
}

/**************************************************************
* 名称 : RefreshFlashSceneMatchGroup
* 功能 : 刷新场景对应的组编号.
*
* 参数 : 
* 返回 : 
*
* 备注 : 1. 最多只查询8组,编号从 0..15.
*        1.   0x1D800 - 0x1D83F  : 第一组的组名数据(组编号为0) 64字节
*        2.   0x1D840 - 0x1D87F  : 第二组的组名数据(组编号为1) 64字节
*        3.   0x1D880 - 0x1D8BF  : 第三组的组名数据(组编号为2) 64字节
*        4.   0x1D8C0 - 0x1D8FF  : 第四组的组名数据(组编号为3) 64字节
*        5.   0x1D900 - 0x1D93F  : 第五组的组名数据(组编号为4) 64字节
*        6.   0x1D940 - 0x1D97F  : 第六组的组名数据(组编号为5) 64字节
*        7.   0x1D980 - 0x1D9BF  : 第七组的组名数据(组编号为6) 64字节
*        8.   0x1D9C0 - 0x1D9FF  : 第八组的组名数据(组编号为7) 64字节
*        9.   0x1DA00 - 0x1DA3F  : 第九组的组名数据(组编号为8) 64字节
*       10.   0x1DA40 - 0x1DA7F  : 第十组的组名数据(组编号为9) 64字节
*       11.   0x1DA80 - 0x1DABF  : 第十一组的组名数据(组编号为10) 64字节
*       12.   0x1DAC0 - 0x1DAFF  : 第十二组的组名数据(组编号为11) 64字节
*       13.   0x1DB00 - 0x1DB3F  : 第十三组的组名数据(组编号为12) 64字节
*       14.   0x1DB40 - 0x1DB7F  : 第十四组的组名数据(组编号为13) 64字节
*       15.   0x1DB80 - 0x1DBBF  : 第十五组的组名数据(组编号为14) 64字节
*       16.   0x1DBC0 - 0x1DBFF  : 第十六组的组名数据(组编号为15) 64字节
*	  
*     注释:每一个场景flash中储存的格式: 组编号+场景名长度+场景名长度异或0xAA+场景名数据 
**************************************************************/
void  RefreshFlashSceneMatchGroup(void)
{
	UINT8    i, *flashRwAddr;

	flashRwAddr = IoTpAd.flash_rw_buf;//读取flash的缓存
	for(i = 0; i < 16; i++)
	{
		spi_flash_read(0x1D800 + (i<<6), flashRwAddr, 64);  flashRwAddr[64] = 0;//结束字符
		if( (flashRwAddr[0] >= 16) ||
		     (flashRwAddr[1] == 0) || 
		     (flashRwAddr[1] != (flashRwAddr[2]^0xAA)) ||
		     (flashRwAddr[1] != strlen(&flashRwAddr[3])) )//组编号>= 16 || 长度为 0 || 如果长度错误 || 记录长度与实际长度不一样
		{
			flashSceneMatchGroup[i] = 0xFF;
		} else {
			flashSceneMatchGroup[i] = flashRwAddr[0];
		}
	}
}

/**************************************************************
* 名称 : ReadSceneName
* 功能 : 读取 场景名
*
* 参数 : pBuff : out   : 要保存场景的缓存指针;
*        ioNum : in_out: 传入查询场景名的开始编号,传出查询的组个数;
*        maxLen : in   : 存储数据的最大长度;
* 返回 : len           : 查询结果占用的数据长度. 0:错误;
*
* 备注 : 1. 最多只查询8组,编号从 0..15.
*        1.   0x1D800 - 0x1D83F  : 第一组的组名数据(组编号为0) 64字节
*        2.   0x1D840 - 0x1D87F  : 第二组的组名数据(组编号为1) 64字节
*        3.   0x1D880 - 0x1D8BF  : 第三组的组名数据(组编号为2) 64字节
*        4.   0x1D8C0 - 0x1D8FF  : 第四组的组名数据(组编号为3) 64字节
*        5.   0x1D900 - 0x1D93F  : 第五组的组名数据(组编号为4) 64字节
*        6.   0x1D940 - 0x1D97F  : 第六组的组名数据(组编号为5) 64字节
*        7.   0x1D980 - 0x1D9BF  : 第七组的组名数据(组编号为6) 64字节
*        8.   0x1D9C0 - 0x1D9FF  : 第八组的组名数据(组编号为7) 64字节
*        9.   0x1DA00 - 0x1DA3F  : 第九组的组名数据(组编号为8) 64字节
*       10.   0x1DA40 - 0x1DA7F  : 第十组的组名数据(组编号为9) 64字节
*       11.   0x1DA80 - 0x1DABF  : 第十一组的组名数据(组编号为10) 64字节
*       12.   0x1DAC0 - 0x1DAFF  : 第十二组的组名数据(组编号为11) 64字节
*       13.   0x1DB00 - 0x1DB3F  : 第十三组的组名数据(组编号为12) 64字节
*       14.   0x1DB40 - 0x1DB7F  : 第十四组的组名数据(组编号为13) 64字节
*       15.   0x1DB80 - 0x1DBBF  : 第十五组的组名数据(组编号为14) 64字节
*       16.   0x1DBC0 - 0x1DBFF  : 第十六组的组名数据(组编号为15) 64字节
*	  
*     注释:每一个场景flash中储存的格式: 组编号+场景名长度+场景名长度异或0xAA+场景名数据 
**************************************************************/
UINT16  ReadSceneName(UINT8 *pBuff, UINT8 *ioNum, const UINT16 maxLen)
{
	UINT8    startNum, num, strLen, tempU8;
	UINT16   i, outLen;
	UINT8   *bufAddr;
	UINT8   *flashRwAddr;

	if((pBuff == NULL) || (ioNum == NULL) || (maxLen < 16))
	{
		return(0);
	}
	startNum = *ioNum;
	if(startNum >= 16)  {  return(0);  }

	flashRwAddr = IoTpAd.flash_rw_buf;//读取flash的缓存
	bufAddr     = &pBuff[32];
	outLen      = 32;
	num         = 0;
	for(i = startNum; i < 16; i++)
	{
		spi_flash_read(0x1D800 + (i<<6), flashRwAddr, 64);  flashRwAddr[64] = 0;//结束字符
		strLen = flashRwAddr[1];
		if( (flashRwAddr[0] >= 16) ||
		     (strLen == 0) || 
		     (strLen != (flashRwAddr[2]^0xAA)) || 
		     (strLen != strlen(&flashRwAddr[3])) )//组编号>= 16 || 长度为 0 || 如果长度错误 || 记录长度与实际长度不一样
		{
			pBuff[num++] = 0xFF; pBuff[num++] = 0;
		} else {
			if((outLen + (strLen + 1)) <= maxLen)//还有空间保存数据
			{
				pBuff[num++] = flashRwAddr[0];//场景对应的 组编号
				pBuff[num++] = strLen+1;//包含 结束字符 0x00

				memcpy(bufAddr, &flashRwAddr[3], (strLen+1));
				bufAddr += (strLen+1);    outLen += (strLen+1);
			} else {//空间不够了,直接跳出
				break;
			}
		}
	}
	if(num == 0)  {  return(0);  }//第一个场景名就超出缓存长度了

	*ioNum = num>>1;//一个场景包括组编号和场景编号,所以要除以2才是真正的场景数量
	//---- 查询完了,要将场景名开始位置从 pBuff[32] 移到正确位置 ----
	if(outLen > 32)//获取了字符串
	{
		if(num < 32)//查询的场景数 小于16,需要将数据移位置
		{
			tempU8 = 32 - num;
			for(i = 32; i < outLen; i++)
			{
				pBuff[i-tempU8] = pBuff[i];
			}
			outLen -= tempU8;
		}
	} else { //没有一组有数据,要处理outLen值
		outLen = num;//查询了几组 组名, outLen 才有 几个字节.
	}

	return(outLen);
}

/**************************************************************
* 名称 : WriteSceneName
* 功能 : 写一个 场景名.
*
* 参数 : GroupNum : in : 组 编号(0..15有效);
*	    SceneNum : in : 场景 编号(0..15有效);
*        pName    : in : 场景名的字符串(包含结束字符0x00);
*        flag     : in : 操作标志. 0x55: 创建场景; 0xAA:修改场景名;
* 返回 : err   : 错误标志. 0:OK;
*
* 备注 : 1.
**************************************************************/
UINT8  WriteSceneName(const UINT8 GroupNum, const UINT8 SceneNum, const UINT8 *pName, const UINT8 flag)
{
	UINT16  tLen,tempSceneNameLen;
	UINT8   *flashRwAddr;

	if( (SceneNum >= 16) || (pName == NULL) || ((flag != 0x55) && (flag != 0xAA)) )
	{
		return(1);//参数错误
	}

	tempSceneNameLen = GetSceneNameLen(SceneNum);
	if( 0xFF == tempSceneNameLen )
	{
		return(1);//参数错误
	}

	if( 0 == (flashGroupData & (((UINT16)0x01)<<GroupNum)) )//组不存在
	{
		return(2);//组编号错误
	}
	
	if( (flag == 0x55) && (tempSceneNameLen != 0) )//创建场景 && 场景已存在
	{
		return(2);//场景编号错误
	}
	if( (flag == 0xAA) && (tempSceneNameLen == 0) )//修改场景名 && 场景不存在
	{
		return(2);//场景编号错误
	}
	tLen = strlen(pName);
	if((tLen == 0) || (tLen > 61))
	{
		return(3);//场景名长度错误
	}
	flashRwAddr = IoTpAd.flash_rw_buf;//读取flash的缓存

	flashRwAddr[0] = GroupNum;
	flashRwAddr[1] = tLen;    flashRwAddr[2] = tLen^0xAA;
	memcpy(&flashRwAddr[3], pName, tLen+1);
	spi_flash_write(0x1D800 + (SceneNum<<6), flashRwAddr, 64);
	flashSceneMatchGroup[SceneNum] = GroupNum;//储存场景对应的 组编号
	
	return(0);
}

/**************************************************************
* 名称 : DelSceneName
* 功能 : 删除 一个 场景.
*
* 参数 : SceneNum : in : 场景 编号(0..15有效);
*    
* 返回 : 
*
* 备注 : 1.
**************************************************************/
UINT8  DelSceneName(const UINT8 SceneNum)
{
	UINT8   *flashRwAddr;

	if(SceneNum >= 16)
	{
		return(1);//参数错误
	}

	flashRwAddr = IoTpAd.flash_rw_buf;//读取flash的缓存
	flashRwAddr[0] = 0xFF;   flashRwAddr[1] = 0;  flashRwAddr[2] = 0;
	spi_flash_write(0x1D800 + (SceneNum<<6), flashRwAddr, 4);
	flashSceneMatchGroup[SceneNum] = 0xFF;//清除场景对应的 组编号
	
	return(0);
}

/**************************************************************
* 名称 : GetSceneNameLen
* 功能 : 通过场景编号,获取对应的场景名的长度.
*
* 参数 : sceneNum : in : 场景 编号(0..15有效);
*        
* 返回 : len   : 0 - 60 ;0xFF:参数错误
*
* 备注 : 1.
**************************************************************/
UINT8  GetSceneNameLen(const UINT8 SceneNum)
{
	UINT8   *flashRwAddr, len;

	len = 0xFF;//默认参数错误
	if(SceneNum >= 16){ goto goto_GetSceneNameLen; }//参数错误

	flashRwAddr = IoTpAd.flash_rw_buf;//读取flash的缓存
	spi_flash_read(0x1D800 + (SceneNum<<6), flashRwAddr, 64); flashRwAddr[64] = 0;//结束字符

	if( (flashRwAddr[0] >= 16) ||
	     (flashRwAddr[1] == 0) || 
	     (flashRwAddr[1] != (flashRwAddr[2]^0xAA)) ||
	     (flashRwAddr[1] != strlen(&flashRwAddr[3])) )//组编号>= 16 || 长度为 0 || 如果长度错误 || 记录长度与实际长度不一样
	{
		len = 0;
	}else{
		len = flashRwAddr[1];
	}

goto_GetSceneNameLen:
	return(len);
}


/**************************************************************
* 名称 : CheckSum
* 功能 : 消息 校验
*
* 参数 : pBuff : in_out :  要校验的缓存指针;
*        iLen  : in :      要校验的数据个数;
* 返回 : sum   : 计算得到的校验码;
*
* 备注 : 1. 检验和 (除了 包头, 包尾, 其他所有数据的XOR)(经验的数据
*            是原始数据,不是转义了的数据)
*        2. pBuff[0] 是包头(0x01),计算校验码时,要剔除.
**************************************************************/
UINT8  CheckSum(UINT8 *pBuff, const UINT16 iLen)
{
	UINT8     tempU8;
	UINT16    i;

	if((pBuff == NULL) || (iLen <= 1))
	{
		return(0);
	}

	for(i = 1, tempU8 = 0; i < iLen; i++)
	{
		tempU8 ^= pBuff[i];
	}

	return(tempU8);
}

#endif
